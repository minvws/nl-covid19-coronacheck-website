// @observablehq/plot v0.2.9 Copyright 2020-2021 Observable, Inc.
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports, require("d3@7.1.1/dist/d3.min.js")) : "function" == typeof define && define.amd ? define(["exports", "d3@7.1.1/dist/d3.min.js"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).Plot = t.Plot || {}, t.d3) }(this, (function (t, e) {
    "use strict"; if ("undefined" != typeof document) { const t = document.createElement("style"); t.textContent = ".plot{display:block;font:10px system-ui,sans-serif;background:#fff;height:auto;height:intrinsic;max-width:100%}.plot text{white-space:pre}", document.head.appendChild(t) } function n(t, e) { if (t instanceof Date || (t = new Date(+t)), isNaN(t)) return "function" == typeof e ? e(t) : e; const n = t.getUTCHours(), o = t.getUTCMinutes(), i = t.getUTCSeconds(), a = t.getUTCMilliseconds(); return `${s = t.getUTCFullYear(), s < 0 ? `-${r(-s, 6)}` : s > 9999 ? `+${r(s, 6)}` : r(s, 4)}-${r(t.getUTCMonth() + 1, 2)}-${r(t.getUTCDate(), 2)}${n || o || i || a ? `T${r(n, 2)}:${r(o, 2)}${i || a ? `:${r(i, 2)}${a ? `.${r(a, 3)}` : ""}` : ""}Z` : ""}`; var s } function r(t, e) { return `${t}`.padStart(e, "0") } const o = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/; function i(t) { return n(t, "Invalid Date") } function a(t) { return null != t && !Number.isNaN(t) } function s(t, n) { return a(n) - a(t) || e.ascending(t, n) } function l(t) { return null != t && "" != `${t}` } function c(t, ...e) { for (const n of e) n && (t = t.filter((t => a(n[t])))); return t } function u(t) { return t > 0 ? t : NaN } function f(t) { return t < 0 ? t : NaN } const d = Symbol("position"), h = Symbol("color"), m = Symbol("radius"), p = Symbol("opacity"), g = new Map([["x", d], ["y", d], ["fx", d], ["fy", d], ["r", m], ["color", h], ["opacity", p]]), y = "undefined" != typeof window && window.devicePixelRatio > 1 ? 0 : .5; function x(t, { title: e, fill: n, fillOpacity: r, stroke: o, strokeOpacity: i, strokeWidth: a }) { k(t, "fill", n && (t => n[t])), k(t, "fill-opacity", r && (t => r[t])), k(t, "stroke", o && (t => o[t])), k(t, "stroke-opacity", i && (t => i[t])), k(t, "stroke-width", a && (t => a[t])), function (t) { return t ? e => e.filter((e => l(t[e]))).append("title").text((e => t[e])) : () => { } }(e)(t) } function v(t, { title: e, fill: n, fillOpacity: r, stroke: o, strokeOpacity: i, strokeWidth: a }) { k(t, "fill", n && (([t]) => n[t])), k(t, "fill-opacity", r && (([t]) => r[t])), k(t, "stroke", o && (([t]) => o[t])), k(t, "stroke-opacity", i && (([t]) => i[t])), k(t, "stroke-width", a && (([t]) => a[t])), function (t) { return t ? e => e.filter((([e]) => l(t[e]))).append("title").text((([e]) => t[e])) : () => { } }(e)(t) } function w(t, e) { k(t, "fill", e.fill), k(t, "fill-opacity", e.fillOpacity), k(t, "stroke", e.stroke), k(t, "stroke-width", e.strokeWidth), k(t, "stroke-opacity", e.strokeOpacity), k(t, "stroke-linejoin", e.strokeLinejoin), k(t, "stroke-linecap", e.strokeLinecap), k(t, "stroke-miterlimit", e.strokeMiterlimit), k(t, "stroke-dasharray", e.strokeDasharray), k(t, "shape-rendering", e.shapeRendering) } function b(t, e) { !function (t, e, n) { null != n && t.style(e, n) }(t, "mix-blend-mode", e.mixBlendMode) } function k(t, e, n) { null != n && t.attr(e, n) } function M(t, e, n, r, o) { e && e.bandwidth && (r += e.bandwidth() / 2), n && n.bandwidth && (o += n.bandwidth() / 2), (r || o) && t.attr("transform", `translate(${r},${o})`) } function R(t, e) { if ((t = at(t)) !== e) return t } function $(t, e) { if ((t = st(t)) !== e) return t } function B(t, { fill: e, fillOpacity: n, stroke: r, strokeOpacity: o, strokeWidth: i }) { return c(t, e, n, r, o, i) } function A(t) { return null == t || "none" === t } function L(t, e) { return null == t ? null === e ? void 0 : e : null == e ? null === t ? void 0 : t : (n, r) => (({ data: n, facets: r } = t(n, r)), e(yt(n), r)) } function T(t) { return (e, n) => { const r = nt(e, t); return { data: e, facets: n.map((t => t.filter((t => r[t])))) } } } function C(t, e) { return { data: t, facets: e.map((t => t.slice().reverse())) } } function O(t) { return ("function" == typeof t && 1 !== t.length ? z : E)(t) } function z(t) { return (e, n) => { const r = (n, r) => t(e[n], e[r]); return { data: e, facets: n.map((t => t.slice().sort(r))) } } } function E(t) { return (e, n) => { const r = nt(e, t), o = (t, e) => s(r[t], r[e]); return { data: e, facets: n.map((t => t.slice().sort(o))) } } } function N({ filter: t, sort: e, reverse: n, transform: r, ...o } = {}, i) { return void 0 === r && (null != t && (r = T(t)), null == e || xt(e) || (r = L(r, O(e))), n && (r = L(r, C))), { ...o, ...xt(e) && { sort: e }, transform: L(r, i) } } function S(t, e, { data: n = X, filter: r, sort: o, reverse: i, ...a } = {}, s = {}) { a = Y(a, s), n = D(n, it), o = null == o ? void 0 : _("sort", o, s), r = null == r ? void 0 : j("filter", r, s); const [l, c] = Lt(t), [u, f] = Lt(e), { z: d, fill: h, stroke: m, x1: p, x2: g, y1: y, y2: x, ...v } = s, [w, b] = Lt(d), [k] = ht(h), [M] = ht(m), [R = h, $] = Lt(k), [B = m, A] = Lt(M); return { ..."z" in s && { z: w || d }, ..."fill" in s && { fill: R || h }, ..."stroke" in s && { stroke: B || m }, ...N(v, ((s, l) => { const u = nt(s, t), h = nt(s, e), m = nt(s, d), p = nt(s, k), g = nt(s, M), y = F(a, m, p, g), x = [], v = [], w = u && c([]), R = h && f([]), B = m && b([]), L = p && $([]), T = g && A([]); let C = 0; for (const t of a) t.initialize(s); o && o.initialize(s), r && r.initialize(s); for (const t of l) { const e = []; for (const e of a) e.scope("facet", t); o && o.scope("facet", t), r && r.scope("facet", t); for (const [i, l] of G(t, y)) for (const [t, c] of G(l, h)) for (const [l, f] of G(c, u)) if (!r || r.reduce(f)) { e.push(C++), v.push(n.reduce(f, s)), u && w.push(l), h && R.push(t), m && B.push(y === m ? i : m[f[0]]), p && L.push(y === p ? i : p[f[0]]), g && T.push(y === g ? i : g[f[0]]); for (const t of a) t.reduce(f); o && o.reduce(f) } x.push(e) } return I(x, o, i), { data: v, facets: x } })), ...!P(a, "x") && (l ? { x: l } : { x1: p, x2: g }), ...!P(a, "y") && (u ? { y: u } : { y1: y, y2: x }), ...Object.fromEntries(a.map((({ name: t, output: e }) => [t, e]))) } } function P(t, ...e) { for (const { name: n } of t) if (e.includes(n)) return !0; return !1 } function Y(t, e) { return Object.entries(t).map((([t, n]) => null == n ? { name: t, initialize() { }, scope() { }, reduce() { } } : _(t, n, e))) } function _(t, e, n) { const r = j(t, e, n), [o, i] = Bt(r.label); let a; return { name: t, output: o, initialize(t) { r.initialize(t), a = i([]) }, scope(t, e) { r.scope(t, e) }, reduce(t, e) { a.push(r.reduce(t, e)) } } } function j(t, e, n) { const r = $t(t, n), o = D(e, r); let i, a; return { label: At(o === V ? null : r, o.label), initialize(t) { i = void 0 === r ? t : nt(t, r), "data" === o.scope && (a = o.reduce(kt(t), i)) }, scope(t, e) { o.scope === t && (a = o.reduce(e, i)) }, reduce: (t, e) => null == o.scope ? o.reduce(t, i, e) : o.reduce(t, i, a, e) } } function G(t, n) { return n ? e.sort(e.group(t, (t => n[t])), ct) : [[, t]] } function D(t, n) { if (t && "function" == typeof t.reduce) return t; if ("function" == typeof t) return r = t, { reduce: (t, e, n) => r(Rt(e, t), n) }; var r; switch (`${t}`.toLowerCase()) { case "first": return U; case "last": return W; case "count": return V; case "distinct": return Z; case "sum": return null == n ? V : H; case "proportion": return Q(n, "data"); case "proportion-facet": return Q(n, "facet"); case "deviation": return q(e.deviation); case "min": return q(e.min); case "min-index": return q(e.minIndex); case "max": return q(e.max); case "max-index": return q(e.maxIndex); case "mean": return q(e.mean); case "median": return q(e.median); case "variance": return q(e.variance); case "mode": return q(e.mode) }throw new Error("invalid reduce") } function F(t, e, n, r) { return function (...t) { for (const e of t) if (void 0 !== e) return e }(t.some((t => "z" === t.name)) ? void 0 : e, t.some((t => "fill" === t.name)) ? void 0 : n, t.some((t => "stroke" === t.name)) ? void 0 : r) } function I(t, e, n) { if (e) { const n = e.output.transform(), r = (t, e) => s(n[t], n[e]); t.forEach((t => t.sort(r))) } n && t.forEach((t => t.reverse())) } function q(t) { return { reduce: (e, n) => t(e, (t => n[t])) } } const X = { reduce: (t, e) => Rt(e, t) }, U = { reduce: (t, e) => e[t[0]] }, W = { reduce: (t, e) => e[t[t.length - 1]] }, V = { label: "Frequency", reduce: t => t.length }, Z = { label: "Distinct", reduce: (t, n) => { const r = new e.InternSet; for (const e of t) r.add(n[e]); return r.size } }, H = q(e.sum); function Q(t, n) { return null == t ? { scope: n, label: "Frequency", reduce: (t, e, n = 1) => t.length / n } : { scope: n, reduce: (t, n, r = 1) => e.sum(t, (t => n[t])) / r } } const J = Object.getPrototypeOf(Uint8Array), K = Object.prototype.toString; class tt { constructor(t, e = [], n = {}, r) { const { facet: o = "auto", sort: i, dx: a, dy: s } = n, l = new Set; this.data = t, this.sort = xt(i) ? i : null, this.facet = null == o || !1 === o ? null : gt(!0 === o ? "include" : o, "facet", ["auto", "include", "exclude"]); const { transform: c } = N(n); this.transform = c, void 0 !== r && (e = function (t, { title: e, fill: n, fillOpacity: r, stroke: o, strokeWidth: i, strokeOpacity: a, strokeLinejoin: s, strokeLinecap: l, strokeMiterlimit: c, strokeDasharray: u, mixBlendMode: f, shapeRendering: d }, h, { fill: m = "currentColor", stroke: p = "none", strokeWidth: g, strokeLinejoin: y, strokeMiterlimit: x }) { null === m && (n = null, r = null), A(m) ? A(p) || A(n) || (p = "none") : A(p) && !A(o) && (m = "none"); const [v, w] = ht(n, m), [b, k] = mt(r), [M, B] = ht(o, p), [L, T] = mt(a); "none" !== B && (void 0 === i && (i = g), void 0 === s && (s = y), void 0 === c && (c = x)); const [C, O] = mt(i); return null !== m && (t.fill = R(w, "currentColor"), t.fillOpacity = $(k, 1)), t.stroke = R(B, "none"), t.strokeWidth = $(O, 1), t.strokeOpacity = $(T, 1), t.strokeLinejoin = R(s, "miter"), t.strokeLinecap = R(l, "butt"), t.strokeMiterlimit = $(c, 4), t.strokeDasharray = at(u), t.mixBlendMode = R(f, "normal"), t.shapeRendering = R(d, "auto"), [...h, { name: "title", value: e, optional: !0 }, { name: "fill", value: v, scale: "color", optional: !0 }, { name: "fillOpacity", value: b, scale: "opacity", optional: !0 }, { name: "stroke", value: M, scale: "color", optional: !0 }, { name: "strokeOpacity", value: L, scale: "opacity", optional: !0 }, { name: "strokeWidth", value: C, optional: !0 }] }(this, n, e, r)), this.channels = e.filter((t => { const { name: e, value: n, optional: r } = t; if (null == n) { if (r) return !1; throw new Error(`missing channel value: ${e}`) } if (void 0 !== e) { const t = `${e}`; if ("__proto__" === t) throw new Error("illegal channel name"); if (l.has(t)) throw new Error(`duplicate channel: ${t}`); l.add(t) } return !0 })), this.dx = +a || 0, this.dy = +s || 0 } initialize(t, n) { let r = yt(this.data), o = void 0 === t && null != r ? kt(r) : t; void 0 !== r && void 0 !== this.transform && (void 0 === t && (o = o.length ? [o] : []), ({ facets: o, data: r } = this.transform(r, o)), r = yt(r), void 0 === t && o.length && ([o] = o)); const i = this.channels.map((t => { const { name: e } = t; return [null == e ? void 0 : `${e}`, et(r, t)] })); return null != this.sort && function (t, n, r, o) { const { reverse: i, reduce: a = !0, limit: s } = o; for (const l in o) { if (!g.has(l)) continue; const { value: c, reverse: u = i, reduce: f = a, limit: d = s } = Ct(o[l]); if (null == f || !1 === f) continue; const h = t.find((([, { scale: t }]) => t === l)) || n && n.find((([, { scale: t }]) => t === l)); if (!h) throw new Error(`missing channel for scale: ${l}`); const m = h[1].value, [p = 0, y = 1 / 0] = d && "function" == typeof d[Symbol.iterator] ? d : d < 0 ? [d] : [0, d]; if (null == c) h[1].domain = () => { let t = m; return u && (t = t.slice().reverse()), 0 === p && y === 1 / 0 || (t = t.slice(p, y)), t }; else { let n; if ("data" === c) n = r; else { const e = t.find((([t]) => t === c)); if (!e) throw new Error(`missing channel: ${c}`); n = e[1].value } const o = D(!0 === f ? "max" : f, n); h[1].domain = () => { let t = e.rollup(kt(m), (t => o.reduce(t, n)), (t => m[t])); return t = e.sort(t, u ? Yt : Pt), 0 === p && y === 1 / 0 || (t = t.slice(p, y)), t.map(ct) } } } }(i, n, r, this.sort), { index: o, channels: i } } plot({ marks: t = [], ...e } = {}) { return Qe({ ...e, marks: [...t, this] }) } } function et(t, { scale: e, type: n, value: r }) { return { scale: e, type: n, value: nt(t, r), label: At(r) } } function nt(t, e, n) { const r = void 0 === n ? Array : n; return "string" == typeof e ? r.from(t, rt(e)) : "function" == typeof e ? r.from(t, e) : "number" == typeof e || e instanceof Date ? r.from(t, ft(e)) : e && "function" == typeof e.transform ? yt(e.transform(t), n) : yt(e, n) } const rt = t => e => e[t], ot = (t, e) => e, it = { transform: t => t }, at = t => null == t ? t : `${t}`, st = t => null == t ? t : +t, lt = t => null == t ? t : !!t, ct = t => t[0], ut = t => t[1], ft = t => () => t, dt = new Set(["currentColor", "none"]); function ht(t, n) { return void 0 === t && (t = n), null === t ? [void 0, "none"] : "string" == typeof t && (dt.has(t) || e.color(t)) ? [void 0, t] : [t, void 0] } function mt(t, e) { return void 0 === t && (t = e), null === t || "number" == typeof t ? [void 0, t] : [t, void 0] } function pt(t, e, n) { if (null != t) return gt(t, e, n) } function gt(t, e, n) { const r = `${t}`.toLowerCase(); if (!n.includes(r)) throw new Error(`invalid ${e}: ${t}`); return r } function yt(t, e) { return null == t ? t : void 0 === e ? t instanceof Array || t instanceof J ? t : Array.from(t) : t instanceof e ? t : e.from(t) } function xt(t) { return t && t.toString === K && "function" != typeof t.transform } function vt(t, e, n, r = it) { return void 0 === e && void 0 === n ? (e = 0, n = void 0 === t ? r : t) : void 0 === e ? e = void 0 === t ? 0 : t : void 0 === n && (n = void 0 === t ? 0 : t), [e, n] } function wt(t, e) { return void 0 === t && void 0 === e ? [ct, ut] : [t, e] } function bt({ z: t, fill: e, stroke: n } = {}) { return void 0 === t && ([t] = ht(e)), void 0 === t && ([t] = ht(n)), t } function kt(t) { return Uint32Array.from(t, ot) } function Mt(t, e) { return kt(t).filter((n => e(t[n], n, t))) } function Rt(t, e) { return Array.from(e, (e => t[e])) } function $t(t, e) { if (void 0 !== e[t]) return e[t]; switch (t) { case "x1": case "x2": t = "x"; break; case "y1": case "y2": t = "y" }return e[t] } function Bt(t) { let e; return [{ transform: () => e, label: At(t) }, t => e = t] } function At(t, e) { return "string" == typeof t ? t : t && void 0 !== t.label ? t.label : e } function Lt(t) { return null == t ? [t] : Bt(t) } function Tt(t, e) { return { transform(n) { const r = t.transform(n), o = e.transform(n); return Et(r) || Et(o) ? Array.from(r, ((t, e) => new Date((+r[e] + +o[e]) / 2))) : Float64Array.from(r, ((t, e) => (+r[e] + +o[e]) / 2)) }, label: t.label } } function Ct(t) { return void 0 === t || xt(t) ? t : { value: t } } function Ot(t) { return { transform: e => nt(e, t, Float64Array), label: At(t) } } function zt(t) { for (const e of t) { if (null == e) continue; const t = typeof e; return "string" === t || "boolean" === t } } function Et(t) { for (const e of t) if (null != e) return e instanceof Date } function Nt(t) { return t instanceof tt ? t : new St(t) } class St extends tt { constructor(t) { if (super(), null != t) { if ("function" != typeof t) throw new TypeError("invalid mark"); this.render = t } } render() { } } function Pt([t, n], [r, o]) { return e.ascending(n, o) || e.ascending(t, r) } function Yt([t, n], [r, o]) { return e.descending(n, o) || e.ascending(t, r) } class _t { constructor({ name: t = "x", axis: e, ticks: n, tickSize: r = ("fx" === t ? 0 : 6), tickPadding: o = (0 === r ? 9 : 3), tickFormat: i, grid: a, label: s, labelAnchor: l, labelOffset: c, line: u, tickRotate: f } = {}) { this.name = t, this.axis = gt(e, "axis", ["top", "bottom"]), this.ticks = n, this.tickSize = st(r), this.tickPadding = st(o), this.tickFormat = i, this.grid = lt(a), this.label = at(s), this.labelAnchor = pt(l, "labelAnchor", ["center", "left", "right"]), this.labelOffset = st(c), this.line = lt(u), this.tickRotate = st(f) } render(t, { [this.name]: n, fy: r }, o, { width: i, height: a, marginTop: s, marginRight: l, marginBottom: c, marginLeft: u, facetMarginTop: f, facetMarginBottom: d, labelMarginLeft: h = 0, labelMarginRight: m = 0 }) { const { axis: p, grid: g, label: y, labelAnchor: x, labelOffset: v, line: w, tickRotate: b } = this, k = "x" === this.name ? 0 : "top" === p ? s - f : c - d, M = "top" === p ? -1 : 1, R = M * k + ("top" === p ? s : a - c); return e.create("svg:g").attr("transform", `translate(0,${R})`).call(Gt("top" === p ? e.axisTop : e.axisBottom, n, this)).call(Ft, b).attr("font-size", null).attr("font-family", null).call(w ? () => { } : t => t.select(".domain").remove()).call(g ? r ? function (t, e, n) { const r = e.bandwidth(), o = e.domain(); return i => i.selectAll(".tick").append("path").attr("stroke", "currentColor").attr("stroke-opacity", .1).attr("d", (t ? Rt(o, t) : o).map((t => `M0,${e(t) + n}v${r}`)).join("")) }(t, r, -R) : ($ = M * (c + s - a), t => t.selectAll(".tick line").clone(!0).attr("stroke-opacity", .1).attr("y2", $)) : () => { }).call(y ? t => t.append("text").attr("fill", "currentColor").attr("transform", `translate(${"center" === x ? (i + u - l) / 2 : "right" === x ? i + m : -h},${v * M})`).attr("dy", "top" === p ? "1em" : "-0.32em").attr("text-anchor", "center" === x ? "middle" : "right" === x ? "end" : "start").text(y) : () => { }).node(); var $ } } class jt { constructor({ name: t = "y", axis: e, ticks: n, tickSize: r = ("fy" === t ? 0 : 6), tickPadding: o = (0 === r ? 9 : 3), tickFormat: i, grid: a, label: s, labelAnchor: l, labelOffset: c, line: u, tickRotate: f } = {}) { this.name = t, this.axis = gt(e, "axis", ["left", "right"]), this.ticks = n, this.tickSize = st(r), this.tickPadding = st(o), this.tickFormat = i, this.grid = lt(a), this.label = at(s), this.labelAnchor = pt(l, "labelAnchor", ["center", "top", "bottom"]), this.labelOffset = st(c), this.line = lt(u), this.tickRotate = st(f) } render(t, { [this.name]: n, fx: r }, o, { width: i, height: a, marginTop: s, marginRight: l, marginBottom: c, marginLeft: u, facetMarginLeft: f, facetMarginRight: d }) { const { axis: h, grid: m, label: p, labelAnchor: g, labelOffset: y, line: x, tickRotate: v } = this, w = "y" === this.name ? 0 : "left" === h ? u - f : l - d, b = "left" === h ? -1 : 1, k = b * w + ("right" === h ? i - l : u); return e.create("svg:g").attr("transform", `translate(${k},0)`).call(Gt("right" === h ? e.axisRight : e.axisLeft, n, this)).call(Ft, v).attr("font-size", null).attr("font-family", null).call(x ? () => { } : t => t.select(".domain").remove()).call(m ? r ? function (t, e, n) { const r = e.bandwidth(), o = e.domain(); return i => i.selectAll(".tick").append("path").attr("stroke", "currentColor").attr("stroke-opacity", .1).attr("d", (t ? Rt(o, t) : o).map((t => `M${e(t) + n},0h${r}`)).join("")) }(t, r, -k) : (M = b * (u + l - i), t => t.selectAll(".tick line").clone(!0).attr("stroke-opacity", .1).attr("x2", M)) : () => { }).call(p ? t => t.append("text").attr("fill", "currentColor").attr("transform", `translate(${y * b},${"center" === g ? (a + s - c) / 2 : "bottom" === g ? a - c : s})${"center" === g ? " rotate(-90)" : ""}`).attr("dy", "center" === g ? "right" === h ? "-0.32em" : "0.75em" : "bottom" === g ? "1.4em" : "-1em").attr("text-anchor", "center" === g ? "middle" : "right" === h ? "end" : "start").text(p) : () => { }).node(); var M } } function Gt(t, n, { ticks: r, tickSize: o, tickPadding: a, tickFormat: s }) { return n.tickFormat || "function" == typeof s || (s = void 0 === s ? Et(n.domain()) ? i : at : ("string" == typeof s ? Et(n.domain()) ? e.utcFormat : e.format : ft)(s)), t(n).ticks(Array.isArray(r) ? null : r, "function" == typeof s ? null : s).tickFormat("function" == typeof s ? s : null).tickSizeInner(o).tickSizeOuter(0).tickPadding(a).tickValues(Array.isArray(r) ? r : null) } const Dt = Math.PI / 180; function Ft(t, e) { if (e = +e) for (const n of t.selectAll("text")) { const t = +n.getAttribute("x"), r = +n.getAttribute("y"); if (Math.abs(r) > Math.abs(t)) { const t = Math.sign(r); n.setAttribute("transform", `translate(0, ${r + 4 * t * Math.cos(e * Dt)}) rotate(${e})`), n.setAttribute("text-anchor", Math.abs(e) < 10 ? "middle" : e < 0 ^ t > 0 ? "start" : "end") } else { const r = Math.sign(t); n.setAttribute("transform", `translate(${t + 4 * r * Math.abs(Math.sin(e * Dt))}, 0) rotate(${e})`), n.setAttribute("text-anchor", Math.abs(e) > 60 ? "middle" : r > 0 ? "start" : "end") } n.removeAttribute("x"), n.removeAttribute("y"), n.setAttribute("dy", "0.32em") } } const It = new Map([["accent", e.schemeAccent], ["category10", e.schemeCategory10], ["dark2", e.schemeDark2], ["paired", e.schemePaired], ["pastel1", e.schemePastel1], ["pastel2", e.schemePastel2], ["set1", e.schemeSet1], ["set2", e.schemeSet2], ["set3", e.schemeSet3], ["tableau10", e.schemeTableau10], ["brbg", Xt(e.schemeBrBG, e.interpolateBrBG)], ["prgn", Xt(e.schemePRGn, e.interpolatePRGn)], ["piyg", Xt(e.schemePiYG, e.interpolatePiYG)], ["puor", Xt(e.schemePuOr, e.interpolatePuOr)], ["rdbu", Xt(e.schemeRdBu, e.interpolateRdBu)], ["rdgy", Xt(e.schemeRdGy, e.interpolateRdGy)], ["rdylbu", Xt(e.schemeRdYlBu, e.interpolateRdYlBu)], ["rdylgn", Xt(e.schemeRdYlGn, e.interpolateRdYlGn)], ["spectral", Xt(e.schemeSpectral, e.interpolateSpectral)], ["burd", Ut(e.schemeRdBu, e.interpolateRdBu)], ["buylrd", Ut(e.schemeRdGy, e.interpolateRdGy)], ["blues", qt(e.schemeBlues, e.interpolateBlues)], ["greens", qt(e.schemeGreens, e.interpolateGreens)], ["greys", qt(e.schemeGreys, e.interpolateGreys)], ["oranges", qt(e.schemeOranges, e.interpolateOranges)], ["purples", qt(e.schemePurples, e.interpolatePurples)], ["reds", qt(e.schemeReds, e.interpolateReds)], ["turbo", Wt(e.interpolateTurbo)], ["viridis", Wt(e.interpolateViridis)], ["magma", Wt(e.interpolateMagma)], ["inferno", Wt(e.interpolateInferno)], ["plasma", Wt(e.interpolatePlasma)], ["cividis", Wt(e.interpolateCividis)], ["cubehelix", Wt(e.interpolateCubehelixDefault)], ["warm", Wt(e.interpolateWarm)], ["cool", Wt(e.interpolateCool)], ["bugn", qt(e.schemeBuGn, e.interpolateBuGn)], ["bupu", qt(e.schemeBuPu, e.interpolateBuPu)], ["gnbu", qt(e.schemeGnBu, e.interpolateGnBu)], ["orrd", qt(e.schemeOrRd, e.interpolateOrRd)], ["pubu", qt(e.schemePuBu, e.interpolatePuBu)], ["pubugn", qt(e.schemePuBuGn, e.interpolatePuBuGn)], ["purd", qt(e.schemePuRd, e.interpolatePuRd)], ["rdpu", qt(e.schemeRdPu, e.interpolateRdPu)], ["ylgn", qt(e.schemeYlGn, e.interpolateYlGn)], ["ylgnbu", qt(e.schemeYlGnBu, e.interpolateYlGnBu)], ["ylorbr", qt(e.schemeYlOrBr, e.interpolateYlOrBr)], ["ylorrd", qt(e.schemeYlOrRd, e.interpolateYlOrRd)], ["rainbow", Vt(e.interpolateRainbow)], ["sinebow", Vt(e.interpolateSinebow)]]); function qt(t, n) { return ({ length: r }) => (r = r > 3 ? Math.floor(r) : 3) > 9 ? e.quantize(n, r) : t[r] } function Xt(t, n) { return ({ length: r }) => 2 === r ? [t[3][0], t[3][2]] : (r = r > 3 ? Math.floor(r) : 3) > 11 ? e.quantize(n, r) : t[r] } function Ut(t, n) { return ({ length: r }) => 2 === r ? [t[3][0], t[3][2]] : (r = r > 3 ? Math.floor(r) : 3) > 11 ? e.quantize((t => n(1 - t)), r) : t[r].slice().reverse() } function Wt(t) { return ({ length: n }) => e.quantize(t, n > 0 ? Math.floor(n) : 0) } function Vt(t) { return ({ length: n }) => e.quantize(t, n > 0 ? Math.floor(n) + 1 : 1).slice(0, -1) } function Zt(t) { const e = `${t}`.toLowerCase(); if (!It.has(e)) throw new Error(`unknown scheme: ${e}`); return It.get(e) } function Ht(t, e) { const n = Zt(t), r = "function" == typeof n ? n({ length: e }) : n; return r.length !== e ? r.slice(0, e) : r } const Qt = new Map([["brbg", e.interpolateBrBG], ["prgn", e.interpolatePRGn], ["piyg", e.interpolatePiYG], ["puor", e.interpolatePuOr], ["rdbu", e.interpolateRdBu], ["rdgy", e.interpolateRdGy], ["rdylbu", e.interpolateRdYlBu], ["rdylgn", e.interpolateRdYlGn], ["spectral", e.interpolateSpectral], ["burd", t => e.interpolateRdBu(1 - t)], ["buylrd", t => e.interpolateRdYlBu(1 - t)], ["blues", e.interpolateBlues], ["greens", e.interpolateGreens], ["greys", e.interpolateGreys], ["purples", e.interpolatePurples], ["reds", e.interpolateReds], ["oranges", e.interpolateOranges], ["turbo", e.interpolateTurbo], ["viridis", e.interpolateViridis], ["magma", e.interpolateMagma], ["inferno", e.interpolateInferno], ["plasma", e.interpolatePlasma], ["cividis", e.interpolateCividis], ["cubehelix", e.interpolateCubehelixDefault], ["warm", e.interpolateWarm], ["cool", e.interpolateCool], ["bugn", e.interpolateBuGn], ["bupu", e.interpolateBuPu], ["gnbu", e.interpolateGnBu], ["orrd", e.interpolateOrRd], ["pubugn", e.interpolatePuBuGn], ["pubu", e.interpolatePuBu], ["purd", e.interpolatePuRd], ["rdpu", e.interpolateRdPu], ["ylgnbu", e.interpolateYlGnBu], ["ylgn", e.interpolateYlGn], ["ylorbr", e.interpolateYlOrBr], ["ylorrd", e.interpolateYlOrRd], ["rainbow", e.interpolateRainbow], ["sinebow", e.interpolateSinebow]]); function Jt(t) { const e = `${t}`.toLowerCase(); if (!Qt.has(e)) throw new Error(`unknown scheme: ${e}`); return Qt.get(e) } const Kt = t => e => t(1 - e), te = [0, 1], ee = new Map([["number", e.interpolateNumber], ["rgb", e.interpolateRgb], ["hsl", e.interpolateHsl], ["hcl", e.interpolateHcl], ["lab", e.interpolateLab]]); function ne(t) { const e = `${t}`.toLowerCase(); if (!ee.has(e)) throw new Error(`unknown interpolator: ${e}`); return ee.get(e) } function re(t, n, r, { type: o, nice: i, clamp: a, zero: s, domain: l = (g.get(t) === m || g.get(t) === p ? se : ae)(r), unknown: c, round: u, scheme: f, range: d = (g.get(t) === m ? le(r, l) : g.get(t) === p ? te : void 0), interpolate: y = (g.get(t) === h ? null == f && void 0 !== d ? e.interpolateRgb : Jt(void 0 !== f ? f : "cyclical" === o ? "rainbow" : "turbo") : u ? e.interpolateRound : e.interpolateNumber), reverse: x }) { if ("cyclical" !== o && "sequential" !== o || (o = "linear"), x = !!x, "function" != typeof y && (y = ne(y)), 1 === y.length ? (x && (y = Kt(y), x = !1), void 0 === d && 2 === (d = Float64Array.from(l, ((t, e) => e / (l.length - 1)))).length && (d = te), n.interpolate((d === te ? ft : fe)(y))) : n.interpolate(y), s) { const [t, n] = e.extent(l); (t > 0 || n < 0) && (Oe(l = Array.from(l)) < 0 ? l[l.length - 1] = 0 : l[0] = 0) } return x && (l = e.reverse(l)), n.domain(l).unknown(c), i && n.nice(!0 === i ? void 0 : i), void 0 !== d && n.range(d), a && n.clamp(a), { type: o, domain: l, range: d, scale: n, interpolate: y } } function oe(t, n, { exponent: r = 1, ...o }) { return re(t, e.scalePow().exponent(r), n, { ...o, type: "pow" }) } function ie(t, n, { domain: r = [0], unknown: o, scheme: i = "rdylbu", interpolate: a, range: s = (void 0 !== a ? e.quantize(a, r.length + 1) : g.get(t) === h ? Ht(i, r.length + 1) : void 0), reverse: l }) { if (!e.pairs(r).every((([t, n]) => e.ascending(t, n) <= 0))) throw new Error("non-ascending domain"); return l && (s = e.reverse(s)), { type: "threshold", scale: e.scaleThreshold(r, void 0 === s ? [] : s).unknown(o), domain: r, range: s } } function ae(t, n) { return [e.min(t, (({ value: t }) => void 0 === t ? t : e.min(t, n))), e.max(t, (({ value: t }) => void 0 === t ? t : e.max(t, n)))] } function se(t) { return [0, e.max(t, (({ value: t }) => void 0 === t ? t : e.max(t)))] } function le(t, n) { const r = e.quantile(t, .5, (({ value: t }) => void 0 === t ? NaN : e.quantile(t, .25, u))), o = n.map((t => 3 * Math.sqrt(t / r))), i = 30 / e.max(o); return i < 1 ? o.map((t => t * i)) : o } function ce(t) { for (const { value: e } of t) if (void 0 !== e) for (let n of e) { if (n = +n, n > 0) return ae(t, u); if (n < 0) return ae(t, f) } return [1, 10] } function ue(t) { const e = []; for (const { value: n } of t) if (void 0 !== n) for (const t of n) e.push(t); return e } function fe(t) { return (e, n) => r => t(e + r * (n - e)) } function de(t, n, r, o, { type: i, nice: a, clamp: s, domain: l = ae(o), unknown: c, pivot: u = 0, scheme: f, range: d, symmetric: m = !0, interpolate: p = (g.get(t) === h ? null == f && void 0 !== d ? e.interpolateRgb : Jt(void 0 !== f ? f : "rdbu") : e.interpolateNumber), reverse: y }) { u = +u; let [x, v] = l; if (x = Math.min(x, u), v = Math.max(v, u), "function" != typeof p && (p = ne(p)), void 0 !== d && (p = 1 === p.length ? fe(p)(...d) : e.piecewise(p, d)), y && (p = Kt(p)), m) { const t = r.apply(u), e = t - r.apply(x), n = r.apply(v) - t; e < n ? x = r.invert(t - n) : e > n && (v = r.invert(t + e)) } return n.domain([x, u, v]).unknown(c).interpolator(p), s && n.clamp(s), a && n.nice(a), { type: i, interpolate: p, scale: n } } function he(t, n, { exponent: r = 1, ...o }) { return de(t, e.scaleDivergingPow().exponent(r = +r), function (t) { return .5 === t ? ye : { apply: e => Math.sign(e) * Math.pow(Math.abs(e), t), invert: e => Math.sign(e) * Math.pow(Math.abs(e), 1 / t) } }(r), n, { ...o, type: "diverging-pow" }) } function me(t, n, { constant: r = 1, ...o }) { return de(t, e.scaleDivergingSymlog().constant(r = +r), function (t) { return { apply: e => Math.sign(e) * Math.log1p(Math.abs(e / t)), invert: e => Math.sign(e) * Math.expm1(Math.abs(e)) * t } }(r), n, o) } const pe = { apply: t => t, invert: t => t }, ge = { apply: Math.log, invert: Math.exp }, ye = { apply: t => Math.sign(t) * Math.sqrt(Math.abs(t)), invert: t => Math.sign(t) * (t * t) }; function xe(t, e, n, r) { return re(t, e, n, r) } function ve(t, n, { type: r, domain: o = be(n), range: i, reverse: a }) { return "categorical" === r && (r = "ordinal"), a && (o = e.reverse(o)), t.domain(o), void 0 !== i && ("function" == typeof i && (i = i(o)), t.range(i)), { type: r, domain: o, range: i, scale: t } } function we(t, e, n) { let { round: r } = n; return void 0 !== r && t.round(r = !!r), (t = ve(t, e, n)).round = r, t } function be(t) { const n = new e.InternSet; for (const { value: e, domain: r } of t) { if (void 0 !== r) return r(); if (void 0 !== e) for (const t of e) n.add(t) } return e.sort(n, s) } function ke(t, e) { if (void 0 === t.range) { const { insetLeft: n, insetRight: r } = t, { width: o, marginLeft: i = 0, marginRight: a = 0 } = e; t.range = [i + n, o - a - r], Le(t) || (t.range = $e(t)), t.scale.range(t.range) } Re(t) } function Me(t, e) { if (void 0 === t.range) { const { insetTop: n, insetBottom: r } = t, { height: o, marginTop: i = 0, marginBottom: a = 0 } = e; t.range = [o - a - r, i + n], Le(t) ? t.range.reverse() : t.range = $e(t), t.scale.range(t.range) } Re(t) } function Re(t) { void 0 === t.round && function ({ type: t }) { return "point" === t || "band" === t }(t) && function ({ scale: t }) { const e = t.domain().length, [n, r] = t.range(), o = t.paddingInner ? t.paddingInner() : 1, i = t.paddingOuter ? t.paddingOuter() : t.padding(), a = e - o, s = Math.abs(r - n) / Math.max(1, a + 2 * i); return (s - Math.floor(s)) * a }(t) <= 30 && t.scale.round(!0) } function $e(t) { const e = t.scale.domain().length + function ({ type: t }) { return "threshold" === t }(t); if (!(e > 2)) return t.range; const [n, r] = t.range; return Array.from({ length: e }, ((t, o) => n + o / (e - 1) * (r - n))) } function Be(t, n = [], r = {}) { const o = function (t, e, { type: n, domain: r, range: o }) { if ("fx" === t || "fy" === t) return "band"; if (void 0 !== n) { for (const { type: t } of e) if (void 0 !== t && n !== t) throw new Error(`scale incompatible with channel: ${n} !== ${t}`); return n } if (g.get(t) === m) return "sqrt"; if (g.get(t) === p) return "linear"; for (const { type: t } of e) if (void 0 !== t) return t; if ((r || o || []).length > 2) return Ae(t); if (void 0 !== r) return zt(r) ? Ae(t) : Et(r) ? "utc" : "linear"; const i = e.map((({ value: t }) => t)).filter((t => void 0 !== t)); return i.some(zt) ? Ae(t) : i.some(Et) ? "utc" : "linear" }(t, n, r); switch (r.type = o, o) { case "diverging": case "diverging-sqrt": case "diverging-pow": case "diverging-log": case "diverging-symlog": case "cyclical": case "sequential": case "linear": case "sqrt": case "threshold": case "quantile": case "pow": case "log": case "symlog": r = Ne(n, r, Pe, Float64Array); break; case "identity": g.get(t) === d && (r = Ne(n, r, Pe, Float64Array)); break; case "utc": case "time": r = Ne(n, r, Ye) }switch (o) { case "diverging": return function (t, n, r) { return de(t, e.scaleDiverging(), pe, n, r) }(t, n, r); case "diverging-sqrt": return function (t, e, n) { return he(t, e, { ...n, exponent: .5 }) }(t, n, r); case "diverging-pow": return he(t, n, r); case "diverging-log": return function (t, n, { base: r = 10, pivot: o = 1, domain: i = ae(n, o < 0 ? f : u), ...a }) { return de(t, e.scaleDivergingLog().base(r = +r), ge, n, { domain: i, pivot: o, ...a }) }(t, n, r); case "diverging-symlog": return me(t, n, r); case "categorical": case "ordinal": return function (t, n, { type: r, scheme: o = ("ordinal" === r ? "turbo" : "tableau10"), range: i = (g.get(t) === h ? Zt(o) : void 0), unknown: a, ...s }) { if (a === e.scaleImplicit) throw new Error("implicit unknown is not supported"); return ve(e.scaleOrdinal().unknown(a), n, { type: r, range: i, ...s }) }(t, n, r); case "cyclical": case "sequential": case "linear": return function (t, n, r) { return re(t, e.scaleLinear(), n, r) }(t, n, r); case "sqrt": return function (t, e, n) { return oe(t, e, { ...n, exponent: .5 }) }(t, n, r); case "threshold": return ie(t, 0, r); case "quantile": return function (t, n, { quantiles: r = 5, scheme: o = "rdylbu", domain: i = ue(n), interpolate: a, range: s = (void 0 !== a ? e.quantize(a, r) : g.get(t) === h ? Ht(o, r) : void 0), reverse: l }) { return ie(t, 0, { domain: e.scaleQuantile(i, void 0 === s ? { length: r } : s).quantiles(), range: s, reverse: l }) }(t, n, r); case "pow": return oe(t, n, r); case "log": return function (t, n, { base: r = 10, domain: o = ce(n), ...i }) { return re(t, e.scaleLog().base(r), n, { ...i, domain: o }) }(t, n, r); case "symlog": return function (t, n, { constant: r = 1, ...o }) { return re(t, e.scaleSymlog().constant(r), n, o) }(t, n, r); case "utc": return function (t, n, r) { return xe(t, e.scaleUtc(), n, r) }(t, n, r); case "time": return function (t, n, r) { return xe(t, e.scaleTime(), n, r) }(t, n, r); case "point": return function (t, n, { align: r = .5, padding: o = .5, ...i }) { return we(e.scalePoint().align(r).padding(o), n, i) }(0, n, r); case "band": return function (t, n, { align: r = .5, padding: o = .1, paddingInner: i = o, paddingOuter: a = ("fx" === t || "fy" === t ? 0 : o), ...s }) { return we(e.scaleBand().align(r).paddingInner(i).paddingOuter(a), n, s) }(t, n, r); case "identity": return g.get(t) === d ? { type: "identity", scale: e.scaleIdentity() } : { type: "identity" }; case void 0: return; default: throw new Error(`unknown scale type: ${r.type}`) } } function Ae(t) { switch (g.get(t)) { case d: return "point"; case h: return "categorical"; default: return "ordinal" } } function Le({ type: t }) { return "ordinal" === t || "point" === t || "band" === t } function Te({ type: t }) { return /^diverging($|-)/.test(t) } function Ce({ range: t, domain: e = t }) { return Math.sign(Oe(e)) * Math.sign(Oe(t)) } function Oe(t) { if (null == t) return; const n = t[0], r = t[t.length - 1]; return e.descending(n, r) } function ze(t = [], e) { const n = Object.create(null); for (let [r, { value: o, scale: i }] of t) void 0 !== r && (void 0 !== i && (i = e[i], void 0 !== i && (o = Array.from(o, i))), n[r] = o); return n } function Ee(t) { const e = t.domain(), n = t(e[0]); for (let r = 1, o = e.length; r < o; ++r)if (t(e[r]) - n) return !1; return !0 } function Ne(t, e, n, r) { for (const e of t) e.value = Se(e.value, n, r); return { ...e, domain: Se(e.domain, n, r) } } function Se(t, e, n = Array) { if (void 0 !== t) return n.from(t, e) } function Pe(t) { return null == t ? NaN : +t } function Ye(t) { return t instanceof Date && !isNaN(t) ? t : "string" == typeof t ? function (t, e) { return o.test(t += "") ? new Date(t) : "function" == typeof e ? e(t) : e }(t) : null == t || isNaN(t = +t) ? void 0 : new Date(t) } function _e(t) { return e => { if (!g.has(e = `${e}`)) throw new Error(`unknown scale: ${e}`); return e in t ? function ({ scale: t, type: e, range: n, label: r, interpolate: o, transform: i, percent: a }) { if ("identity" === e) return { type: "identity" }; const s = t.domain(), l = t.unknown ? t.unknown() : void 0; return { type: e, domain: s, ...void 0 !== n && { range: Array.from(n) }, ...void 0 !== i && { transform: i }, ...a && { percent: a }, ...void 0 !== r && { label: r }, ...void 0 !== l && { unknown: l }, ...void 0 !== o && { interpolate: o }, ...t.clamp && { clamp: t.clamp() }, ...Te({ type: e }) && (([t, e, n]) => ({ domain: [t, n], pivot: e }))(s), ...t.base && { base: t.base() }, ...t.exponent && { exponent: t.exponent() }, ...t.constant && { constant: t.constant() }, ...t.align && { align: t.align(), round: t.round() }, ...t.padding && (t.paddingInner ? { paddingInner: t.paddingInner(), paddingOuter: t.paddingOuter() } : { padding: t.padding() }) } }(t[e]) : void 0 } } function je(t, n, r) { if (void 0 === n.ticks) { const [o, i] = e.extent(t.scale.range()); n.ticks = (i - o) / r } } function Ge(t, e, n) { void 0 === t.labelAnchor && (t.labelAnchor = Le(e) ? "center" : Ce(e) < 0 ? "left" : "right"), void 0 === t.label && (t.label = Ie(n, e, t, "x")), e.label = t.label } function De(t, e, n, r) { void 0 === t.labelAnchor && (t.labelAnchor = Le(n) ? "center" : e && "top" === e.axis ? "bottom" : "top"), void 0 === t.label && (t.label = Ie(r, n, t, "y")), n.label = t.label } function Fe(t, e, n, r) { r && (e.label = r.label), void 0 === e.label && (e.label = Ie(n, e, null, t)) } function Ie(t = [], e, n, r) { let o; for (const { label: e } of t) if (void 0 !== e) if (void 0 === o) o = e; else if (o !== e) return; if (void 0 !== o) { if (function ({ type: t }) { return "time" === t || "utc" === t }(e) && /^(date|time|year)$/i.test(o)) return; if (!Le(e) && (e.percent && (o = `${o} (%)`), "x" === r || "y" === r)) { const t = Ce(e); t && (o = "x" === r || n && "center" === n.labelAnchor ? "x" === r == t < 0 ? `← ${o}` : `${o} →` : `${t < 0 ? "↑ " : "↓ "}${o}`) } } return o } function qe(t, { x: e, y: n, ...r }, o) { return void 0 === e && void 0 === n ? o : [new Xe(t, { x: e, y: n, ...r }, o)] } class Xe extends tt { constructor(t, { x: e, y: n, ...r } = {}, o = []) { if (null == t) throw new Error("missing facet data"); super(t, [{ name: "fx", value: e, scale: "fx", optional: !0 }, { name: "fy", value: n, scale: "fy", optional: !0 }], r), this.marks = o.flat(1 / 0).map(Nt), this.marksChannels = void 0, this.marksIndexByFacet = void 0 } initialize() { const { index: t, channels: n } = super.initialize(), r = void 0 === t ? [] : function (t, e) { return (e.length > 1 ? Ve : We)(t, ...e) }(t, n), o = Array.from(r, ct), i = Array.from(r, ut), a = [], s = this.marksChannels = [], l = this.marksIndexByFacet = function (t) { return new (t.length > 1 ? He : Ze) }(n); for (const t of o) l.set(t, new Array(this.marks.length)); let c; for (let r = 0; r < this.marks.length; ++r) { const u = this.marks[r], { facet: f } = u, d = "auto" === f ? u.data === this.data ? i : void 0 : "include" === f ? i : "exclude" === f ? c || (c = i.map((n => Uint32Array.from(e.difference(t, n))))) : void 0, { index: h, channels: m } = u.initialize(d, n); if (void 0 !== h) if (d) for (let t = 0; t < o.length; ++t)l.get(o[t])[r] = h[t]; else for (let t = 0; t < o.length; ++t)l.get(o[t])[r] = h; for (const [, t] of m) a.push([, t]); s.push(m) } return { index: t, channels: [...n, ...a] } } render(t, n, r, o, i) { const { marks: a, marksChannels: s, marksIndexByFacet: l } = this, { fx: c, fy: u } = n, f = u && u.domain(), d = c && c.domain(), h = u && { marginTop: 0, marginBottom: 0, height: u.bandwidth() }, m = c && { marginRight: 0, marginLeft: 0, width: c.bandwidth() }, p = { ...o, ...m, ...h }, g = s.map((t => ze(t, n))); return e.create("svg:g").call((t => { if (u && i.y) { const e = i.y, r = Ue(e), a = "bottom" === e.labelAnchor ? f.length - 1 : "center" === e.labelAnchor ? f.length >> 1 : 0, s = { ...o, ...h }; t.selectAll().data(f).join("g").attr("transform", (t => `translate(0,${u(t)})`)).append(((t, o) => (o === a ? e : r).render(c && Mt(d, (e => l.has([e, t]))), n, null, s))) } if (c && i.x) { const e = i.x, r = Ue(e), a = "right" === e.labelAnchor ? d.length - 1 : "center" === e.labelAnchor ? d.length >> 1 : 0, { marginLeft: s, marginRight: h } = o, p = { ...o, ...m, labelMarginLeft: s, labelMarginRight: h }; t.selectAll().data(d).join("g").attr("transform", (t => `translate(${c(t)},0)`)).append(((t, o) => (o === a ? e : r).render(u && Mt(f, (e => l.has([t, e]))), n, null, p))) } })).call((t => t.selectAll().data(function ({ fx: t, fy: n }) { return t && n ? e.cross(t.domain(), n.domain()) : t ? t.domain() : n.domain() }(n).filter(l.has, l)).join("g").attr("transform", function (t, e) { return t && e ? ([n, r]) => `translate(${t(n)},${e(r)})` : t ? e => `translate(${t(e)},0)` : t => `translate(0,${e(t)})` }(c, u)).each((function (t) { const e = l.get(t); for (let t = 0; t < a.length; ++t) { const r = g[t], o = B(e[t], r), i = a[t].render(o, n, r, p); null != i && this.appendChild(i) } })))).node() } } function Ue(t) { return void 0 === t || void 0 === t.label ? t : Object.assign(Object.create(t), { label: void 0 }) } function We(t, [, { value: n }]) { return e.groups(t, (t => n[t])) } function Ve(t, [, { value: n }], [, { value: r }]) { return e.groups(t, (t => n[t]), (t => r[t])).flatMap((([t, e]) => e.map((([e, n]) => [[t, e], n])))) } class Ze { constructor() { this._ = new e.InternMap } has(t) { return this._.has(t) } get(t) { return this._.get(t) } set(t, e) { return this._.set(t, e), this } } class He extends Ze { has([t, e]) { const n = super.get(t); return !!n && n.has(e) } get([t, e]) { const n = super.get(t); return n && n.get(e) } set([t, n], r) { const o = super.get(t); return o ? o.set(n, r) : super.set(t, new e.InternMap([[n, r]])), this } } function Qe(t = {}) { const { facet: n, style: r, caption: o } = t; if (void 0 !== n) { const { marks: e } = t, { data: r } = n; t = { ...t, marks: qe(r, n, e) } } const i = void 0 === t.marks ? [] : t.marks.flat(1 / 0).map(Nt), a = new Map, s = new Map, l = new Map; for (const e of i) { if (a.has(e)) throw new Error("duplicate mark"); const { index: n, channels: r } = e.initialize(); for (const [, e] of r) { const { scale: n } = e; if (void 0 !== n) { const r = l.get(n), { percent: o, transform: i = (o ? t => 100 * t : void 0) } = t[n] || {}; null != i && (e.value = Array.from(e.value, i)), r ? r.push(e) : l.set(n, [e]) } } a.set(e, r), s.set(e, n) } const c = function (t, { inset: e = 0, insetTop: n = e, insetRight: r = e, insetBottom: o = e, insetLeft: i = e, round: a, nice: s, align: l, padding: c, ...u } = {}) { const f = {}; for (const e of g.keys()) { const h = t.get(e), m = u[e]; if (h || m) { const t = Be(e, h, { round: g.get(e) === d ? a : void 0, nice: s, align: l, padding: c, ...m }); if (t) { let { percent: a, transform: s, inset: l, insetTop: c = (void 0 !== l ? l : "y" === e ? n : 0), insetRight: u = (void 0 !== l ? l : "x" === e ? r : 0), insetBottom: d = (void 0 !== l ? l : "y" === e ? o : 0), insetLeft: h = (void 0 !== l ? l : "x" === e ? i : 0) } = m || {}; if (null == s) s = void 0; else if ("function" != typeof s) throw new Error("invalid scale transform"); t.percent = !!a, t.transform = s, "x" === e || "fx" === e ? (t.insetLeft = +h, t.insetRight = +u) : "y" !== e && "fy" !== e || (t.insetTop = +c, t.insetBottom = +d), f[e] = t } } } return f }(l, t), u = function (t) { return Object.fromEntries(Object.entries(t).map((([t, { scale: e }]) => [t, e]))) }(c), f = function ({ x: t, y: e, fx: n, fy: r }, { x: o = {}, y: i = {}, fx: a = {}, fy: s = {}, axis: l = !0, grid: c, line: u, label: f, facet: { axis: d = l, grid: h, label: m = f } = {} } = {}) { let { axis: p = l } = o, { axis: g = l } = i, { axis: y = d } = a, { axis: x = d } = s; return t ? !0 === p && (p = "bottom") : p = null, e ? !0 === g && (g = "left") : g = null, n ? !0 === y && (y = "bottom" === p ? "top" : "bottom") : y = null, r ? !0 === x && (x = "left" === g ? "right" : "left") : x = null, { ...p && { x: new _t({ grid: c, line: u, label: f, ...o, axis: p }) }, ...g && { y: new jt({ grid: c, line: u, label: f, ...i, axis: g }) }, ...y && { fx: new _t({ name: "fx", grid: h, label: m, ...a, axis: y }) }, ...x && { fy: new jt({ name: "fy", grid: h, label: m, ...s, axis: x }) } } }(c, t), h = function (t, { x: { axis: e } = {}, y: { axis: n } = {}, fx: { axis: r } = {}, fy: { axis: o } = {} }, { width: i = 640, height: a = Je(t), facet: { marginTop: s = ("top" === r ? 30 : 0), marginRight: l = ("right" === o ? 40 : 0), marginBottom: c = ("bottom" === r ? 30 : 0), marginLeft: u = ("left" === o ? 40 : 0) } = {}, marginTop: f = Math.max(("top" === e ? 30 : 0) + s, n || o ? 20 : .5 - y), marginRight: d = Math.max(("right" === n ? 40 : 0) + l, e || r ? 20 : .5 + y), marginBottom: h = Math.max(("bottom" === e ? 30 : 0) + c, n || o ? 20 : .5 + y), marginLeft: m = Math.max(("left" === n ? 40 : 0) + u, e || r ? 20 : .5 - y) } = {}) { return { width: i, height: a, marginTop: f, marginRight: d, marginBottom: h, marginLeft: m, facetMarginTop: s, facetMarginRight: l, facetMarginBottom: c, facetMarginLeft: u } }(c, f, t); !function ({ x: t, y: e, fx: n, fy: r }, o) { n && ke(n, o), r && Me(r, o), t && ke(t, n ? { width: n.scale.bandwidth() } : o), e && Me(e, r ? { height: r.scale.bandwidth() } : o) }(c, h), function (t, e, { x: n, y: r, fx: o, fy: i }, a, s) { if (o && (Ge(o, e.fx, t.get("fx")), void 0 === o.labelOffset)) { const { facetMarginTop: t, facetMarginBottom: e } = a; o.labelOffset = "top" === o.axis ? t : e } if (i && (De(i, o, e.fy, t.get("fy")), void 0 === i.labelOffset)) { const { facetMarginLeft: t, facetMarginRight: e } = a; i.labelOffset = "left" === i.axis ? t : e } if (n && (Ge(n, e.x, t.get("x")), void 0 === n.labelOffset)) { const { marginTop: t, marginBottom: e, facetMarginTop: r, facetMarginBottom: o } = a; n.labelOffset = "top" === n.axis ? t - r : e - o } if (r && (De(r, n, e.y, t.get("y")), void 0 === r.labelOffset)) { const { marginRight: t, marginLeft: e, facetMarginLeft: n, facetMarginRight: o } = a; r.labelOffset = "left" === r.axis ? e - n : t - o } for (const [n, r] of g) r !== d && e[n] && Fe(n, e[n], t.get(n), s[n]) }(l, c, f, h, t), function ({ x: t, y: e, fx: n, fy: r }, { x: o, y: i, fx: a, fy: s }) { a && je(n, a, 80), s && je(r, s, 35), o && je(t, o, 80), i && je(e, i, 35) }(c, f), t = { ...c, ...h }, f.x && (t.x = { ...t.x, ...f.x }), f.y && (t.y = { ...t.y, ...f.y }), f.fx && (t.fx = { ...t.fx, ...f.fx }), f.fy && (t.fy = { ...t.fy, ...f.fy }); const m = void 0 !== n && u.fx ? "fx" : "x", p = void 0 !== n && u.fy ? "fy" : "y"; f[m] && i.unshift(f[m]), f[p] && i.unshift(f[p]); const { width: x, height: v } = h, w = e.create("svg").attr("class", "plot").attr("fill", "currentColor").attr("text-anchor", "middle").attr("width", x).attr("height", v).attr("viewBox", `0 0 ${x} ${v}`).each((function () { "string" == typeof r ? this.style = r : Object.assign(this.style, r) })).node(); for (const t of i) { const e = ze(a.get(t), u), n = B(s.get(t), e), r = t.render(n, u, e, h, f); null != r && w.appendChild(r) } let b = w; if (null != o) { b = document.createElement("figure"), b.appendChild(w); b.appendChild(document.createElement("figcaption")).appendChild(o instanceof Node ? o : document.createTextNode(o)) } return b.scale = _e(c), b } function Je({ y: t, fy: e, fx: n }) { const r = e ? e.scale.domain().length : 1, o = t ? Le(t) ? t.scale.domain().length : Math.max(7, 17 / r) : 1; return !(!t && !e) * Math.max(1, Math.min(60, o * r)) * 20 + 30 * !!n + 60 } const Ke = new Map([["basis", e.curveBasis], ["basis-closed", e.curveBasisClosed], ["basis-open", e.curveBasisOpen], ["bundle", e.curveBundle], ["bump-x", e.curveBumpX], ["bump-y", e.curveBumpY], ["cardinal", e.curveCardinal], ["cardinal-closed", e.curveCardinalClosed], ["cardinal-open", e.curveCardinalOpen], ["catmull-rom", e.curveCatmullRom], ["catmull-rom-closed", e.curveCatmullRomClosed], ["catmull-rom-open", e.curveCatmullRomOpen], ["linear", e.curveLinear], ["linear-closed", e.curveLinearClosed], ["monotone-x", e.curveMonotoneX], ["monotone-y", e.curveMonotoneY], ["natural", e.curveNatural], ["step", e.curveStep], ["step-after", e.curveStepAfter], ["step-before", e.curveStepBefore]]); function tn(t = e.curveLinear, n) { if ("function" == typeof t) return t; const r = Ke.get(`${t}`.toLowerCase()); if (!r) throw new Error(`unknown curve: ${t}`); if (void 0 !== n) switch (r) { case e.curveBundle: return r.beta(n); case e.curveCardinalClosed: case e.curveCardinalOpen: case e.curveCardinal: return r.tension(n); case e.curveCatmullRomClosed: case e.curveCatmullRomOpen: case e.curveCatmullRom: return r.alpha(n) }return r } function en(t = {}) { const { x: e, x1: n, x2: r } = t; return void 0 === n && void 0 === r && void 0 === e ? { ...t, x: it } : t } function nn(t = {}) { const { y: e, y1: n, y2: r } = t; return void 0 === n && void 0 === r && void 0 === e ? { ...t, y: it } : t } function rn(t = {}, e = {}) { 1 === arguments.length && ([t, e] = cn(t)); const { y1: n, y: r = n, x: o, ...i } = e, [a, s, l, c] = un(r, o, "x", t, i); return { ...a, y1: n, y: s, x1: l, x2: c, x: Tt(l, c) } } function on(t = {}, e = {}) { 1 === arguments.length && ([t, e] = cn(t)); const { x1: n, x: r = n, y: o, ...i } = e, [a, s, l, c] = un(r, o, "y", t, i); return { ...a, x1: n, x: s, y1: l, y2: c, y: Tt(l, c) } } function an({ x: t, x1: e, x2: n, ...r } = {}) { return r = ln(r, "x"), void 0 === e && void 0 === n ? rn({ x: t, ...r }) : ([e, n] = vt(t, e, n), { ...r, x1: e, x2: n }) } function sn({ y: t, y1: e, y2: n, ...r } = {}) { return r = ln(r, "y"), void 0 === e && void 0 === n ? on({ y: t, ...r }) : ([e, n] = vt(t, e, n), { ...r, y1: e, y2: n }) } function ln(t, e) { let { sort: n } = t; if (!xt(n)) return t; for (const t in n) { const { value: r, ...o } = Ct(n[t]); r === e && (n = { ...n, [t]: { value: `${r}2`, ...o } }) } return { ...t, sort: n } } function cn(t) { const { offset: e, order: n, reverse: r, ...o } = t; return [{ offset: e, order: n, reverse: r }, o] } function un(t, n = (() => 1), r, { offset: o, order: i, reverse: a }, s) { const l = bt(s), [c, u] = Lt(t), [f, d] = Bt(n), [h, m] = Bt(n); return o = function (t) { if (null == t) return; switch (`${t}`.toLowerCase()) { case "expand": case "normalize": return dn; case "center": case "silhouette": return hn; case "wiggle": return mn }throw new Error(`unknown offset: ${t}`) }(o), i = function (t, e, n) { if (void 0 === t && e === mn) return bn; if (null == t) return; if ("string" == typeof t) { switch (t.toLowerCase()) { case "value": case n: return yn; case "z": return xn; case "sum": return vn; case "appearance": return wn; case "inside-out": return bn }return kn(rt(t)) } if ("function" == typeof t) return kn(t); if (Array.isArray(t)) return r = t, (t, e, n, o) => Mn(o, r); var r; throw new Error("invalid order") }(i, o, r), [N(s, ((r, s) => { const c = null == t ? void 0 : u(nt(r, t)), f = nt(r, n, Float64Array), h = nt(r, l), p = i && i(r, c, f, h), g = r.length, y = d(new Float64Array(g)), x = m(new Float64Array(g)), v = []; for (const t of s) { const n = c ? Array.from(e.group(t, (t => c[t])).values()) : [t]; p && Rn(n, p); for (const t of n) { let e = 0, n = 0; a && t.reverse(); for (const r of t) { const t = f[r]; t < 0 ? e = x[r] = (y[r] = e) + t : t > 0 ? n = x[r] = (y[r] = n) + t : x[r] = y[r] = n } } v.push(n) } return o && o(v, y, x, h), { data: r, facets: s } })), c, f, h] } function fn(t, e) { let n = 0, r = 0; for (const o of t) { const t = e[o]; t < n && (n = t), t > r && (r = t) } return [n, r] } function dn(t, e, n) { for (const r of t) for (const t of r) { const [r, o] = fn(t, n); for (const i of t) { const t = 1 / (o - r || 1); e[i] = t * (e[i] - r), n[i] = t * (n[i] - r) } } } function hn(t, e, n) { for (const r of t) { for (const t of r) { const [r, o] = fn(t, n); for (const i of t) { const t = (o + r) / 2; e[i] -= t, n[i] -= t } } pn(r, e, n) } gn(t, e, n) } function mn(t, n, r, o) { for (const i of t) { const t = new e.InternMap; let a = 0; for (const s of i) { let i = -1; const l = s.map((t => Math.abs(r[t] - n[t]))), c = s.map((e => { i = o ? o[e] : ++i; const a = r[e] - n[e], s = t.has(i) ? a - t.get(i) : 0; return t.set(i, a), s })), u = [0, ...e.cumsum(c)]; for (const t of s) n[t] += a, r[t] += a; const f = e.sum(l); f && (a -= e.sum(l, ((t, e) => (c[e] / 2 + u[e]) * t)) / f) } pn(i, n, r) } gn(t, n, r) } function pn(t, n, r) { const o = e.min(t, (t => e.min(t, (t => n[t])))); for (const e of t) for (const t of e) n[t] -= o, r[t] -= o } function gn(t, n, r) { const o = t.length; if (1 === o) return; const i = t.map((t => t.flat())), a = i.map((t => (e.min(t, (t => n[t])) + e.max(t, (t => r[t]))) / 2)), s = e.min(a); for (let t = 0; t < o; t++) { const e = s - a[t]; for (const o of i[t]) n[o] += e, r[o] += e } } function yn(t, e, n) { return n } function xn(t, e, n, r) { return r } function vn(t, n, r, o) { return Mn(o, e.groupSort(kt(t), (t => e.sum(t, (t => r[t]))), (t => o[t]))) } function wn(t, n, r, o) { return Mn(o, e.groupSort(kt(t), (t => n[e.greatest(t, (t => r[t]))]), (t => o[t]))) } function bn(t, n, r, o) { const i = kt(t), a = e.groupSort(i, (t => n[e.greatest(t, (t => r[t]))]), (t => o[t])), s = e.rollup(i, (t => e.sum(t, (t => r[t]))), (t => o[t])), l = [], c = []; let u = 0; for (const t of a) u < 0 ? (u += s.get(t), l.push(t)) : (u -= s.get(t), c.push(t)); return Mn(o, c.reverse().concat(l)) } function kn(t) { return e => nt(e, t) } function Mn(t, n) { return n = new e.InternMap(n.map(((t, e) => [t, e]))), t.map((t => n.get(t))) } function Rn(t, e) { for (const n of t) n.sort(((t, n) => s(e[t], e[n]))) } const $n = { strokeWidth: 1, strokeMiterlimit: 1 }; class Bn extends tt { constructor(t, e = {}) { const { x1: n, y1: r, x2: o, y2: i, curve: a, tension: s } = e; super(t, [{ name: "x1", value: n, scale: "x" }, { name: "y1", value: r, scale: "y" }, { name: "x2", value: o, scale: "x", optional: !0 }, { name: "y2", value: i, scale: "y", optional: !0 }, { name: "z", value: bt(e), optional: !0 }], e, $n), this.curve = tn(a, s) } render(t, { x: n, y: r }, o) { const { x1: i, y1: s, x2: l = i, y2: c = s, z: u } = o, { dx: f, dy: d } = this; return e.create("svg:g").call(w, this).call(M, n, r, f, d).call((n => n.selectAll().data(u ? e.group(t, (t => u[t])).values() : [t]).join("path").call(b, this).call(v, o).attr("d", e.area().curve(this.curve).defined((t => a(i[t]) && a(s[t]) && a(l[t]) && a(c[t]))).x0((t => i[t])).y0((t => s[t])).x1((t => l[t])).y1((t => c[t]))))).node() } } function An({ inset: t, insetLeft: e, insetRight: n, ...r } = {}) { return [e, n] = Tn(t, e, n), { inset: t, insetLeft: e, insetRight: n, ...r } } function Ln({ inset: t, insetTop: e, insetBottom: n, ...r } = {}) { return [e, n] = Tn(t, e, n), { inset: t, insetTop: e, insetBottom: n, ...r } } function Tn(t, e, n) { return void 0 === t && void 0 === e && void 0 === n ? y ? [1, 0] : [.5, .5] : [e, n] } function Cn(t, { interval: e }) { return (t = { ...Ct(t) }).interval = function (t) { if (null != t) { if ("number" == typeof t) { const e = t; t = { floor: t => e * Math.floor(t / e), offset: t => t + e } } if ("function" != typeof t.floor || "function" != typeof t.offset) throw new Error("invalid interval"); return t } }(void 0 === t.interval ? e : t.interval), t } function On(t, e, n) { const { [t]: r, [`${t}1`]: o, [`${t}2`]: i } = n, { value: a, interval: s } = Cn(r, n); if (null == a || null == s) return n; let l; const c = t => l || (l = nt(t, a).map((t => s.floor(t)))), u = At(r); return e({ ...n, [t]: void 0, [`${t}1`]: void 0 === o ? { transform: c, label: u } : o, [`${t}2`]: void 0 === i ? { transform: () => c().map((t => s.offset(t))), label: u } : i }) } function zn(t = {}) { return On("x", An, t) } function En(t = {}) { return On("y", Ln, t) } const Nn = {}; class Sn extends tt { constructor(t, e, n = {}) { super(t, e, n, Nn); const { inset: r = 0, insetTop: o = r, insetRight: i = r, insetBottom: a = r, insetLeft: s = r, rx: l, ry: c } = n; this.insetTop = st(o), this.insetRight = st(i), this.insetBottom = st(a), this.insetLeft = st(s), this.rx = R(l, "auto"), this.ry = R(c, "auto") } render(t, n, r, o) { const { dx: i, dy: a, rx: s, ry: l } = this, u = c(t, ...this._positions(r)); return e.create("svg:g").call(w, this).call(this._transform, n, i, a).call((t => t.selectAll().data(u).join("rect").call(b, this).attr("x", this._x(n, r, o)).attr("width", this._width(n, r, o)).attr("y", this._y(n, r, o)).attr("height", this._height(n, r, o)).call(k, "rx", s).call(k, "ry", l).call(x, r))).node() } _x(t, { x: e }, { marginLeft: n }) { const { insetLeft: r } = this; return e ? t => e[t] + r : n + r } _y(t, { y: e }, { marginTop: n }) { const { insetTop: r } = this; return e ? t => e[t] + r : n + r } _width({ x: t }, { x: e }, { marginRight: n, marginLeft: r, width: o }) { const { insetLeft: i, insetRight: a } = this, s = e ? t.bandwidth() : o - n - r; return Math.max(0, s - i - a) } _height({ y: t }, { y: e }, { marginTop: n, marginBottom: r, height: o }) { const { insetTop: i, insetBottom: a } = this, s = e ? t.bandwidth() : o - n - r; return Math.max(0, s - i - a) } } class Pn extends Sn { constructor(t, e = {}) { const { x1: n, x2: r, y: o } = e; super(t, [{ name: "x1", value: n, scale: "x" }, { name: "x2", value: r, scale: "x" }, { name: "y", value: o, scale: "y", type: "band", optional: !0 }], e) } _transform(t, { x: e }, n, r) { t.call(M, e, null, n, r) } _positions({ x1: t, x2: e, y: n }) { return [t, e, n] } _x({ x: t }, { x1: e, x2: n }, { marginLeft: r }) { const { insetLeft: o } = this; return Ee(t) ? r + o : t => Math.min(e[t], n[t]) + o } _width({ x: t }, { x1: e, x2: n }, { marginRight: r, marginLeft: o, width: i }) { const { insetLeft: a, insetRight: s } = this; return Ee(t) ? i - r - o - a - s : t => Math.max(0, Math.abs(n[t] - e[t]) - a - s) } } class Yn extends Sn { constructor(t, e = {}) { const { x: n, y1: r, y2: o } = e; super(t, [{ name: "y1", value: r, scale: "y" }, { name: "y2", value: o, scale: "y" }, { name: "x", value: n, scale: "x", type: "band", optional: !0 }], e) } _transform(t, { y: e }, n, r) { t.call(M, null, e, n, r) } _positions({ y1: t, y2: e, x: n }) { return [t, e, n] } _y({ y: t }, { y1: e, y2: n }, { marginTop: r }) { const { insetTop: o } = this; return Ee(t) ? r + o : t => Math.min(e[t], n[t]) + o } _height({ y: t }, { y1: e, y2: n }, { marginTop: r, marginBottom: o, height: i }) { const { insetTop: a, insetBottom: s } = this; return Ee(t) ? i - r - o - a - s : t => Math.max(0, Math.abs(n[t] - e[t]) - a - s) } } class _n extends Sn { constructor(t, { x: e, y: n, ...r } = {}) { super(t, [{ name: "x", value: e, scale: "x", type: "band", optional: !0 }, { name: "y", value: n, scale: "y", type: "band", optional: !0 }], r) } _transform() { } _positions({ x: t, y: e }) { return [t, e] } } const jn = { fill: "none", stroke: "currentColor", strokeWidth: 1.5 }; class Gn extends tt { constructor(t, e = {}) { const { x: n, y: r, r: o } = e, [i, a] = mt(o, 3); super(t, [{ name: "x", value: n, scale: "x", optional: !0 }, { name: "y", value: r, scale: "y", optional: !0 }, { name: "r", value: i, scale: "r", optional: !0 }], e, jn), this.r = a } render(t, { x: n, y: r }, o, { width: i, height: a, marginTop: s, marginRight: l, marginBottom: f, marginLeft: d }) { const { x: h, y: m, r: p } = o, { dx: g, dy: v } = this; let k = c(t, h, m); return p && (k = k.filter((t => u(p[t])))), e.create("svg:g").call(w, this).call(M, n, r, y + g, y + v).call((t => t.selectAll().data(k).join("circle").call(b, this).attr("cx", h ? t => h[t] : (d + i - l) / 2).attr("cy", m ? t => m[t] : (s + a - f) / 2).attr("r", p ? t => p[t] : this.r).call(x, o))).node() } } const Dn = { fill: "none", stroke: "currentColor" }; class Fn extends tt { constructor(t = {}) { const { inset: e = 0, insetTop: n = e, insetRight: r = e, insetBottom: o = e, insetLeft: i = e } = t; super(void 0, void 0, t, Dn), this.insetTop = st(n), this.insetRight = st(r), this.insetBottom = st(o), this.insetLeft = st(i) } render(t, n, r, o) { const { marginTop: i, marginRight: a, marginBottom: s, marginLeft: l, width: c, height: u } = o, { insetTop: f, insetRight: d, insetBottom: h, insetLeft: m, dx: p, dy: g } = this; return e.create("svg:rect").call(w, this).call(b, this).call(M, null, null, y + p, y + g).attr("x", l + m).attr("y", i + f).attr("width", c - l - a - m - d).attr("height", u - i - s - f - h).node() } } const In = { fill: "none", stroke: "currentColor", strokeWidth: 1.5, strokeMiterlimit: 1 }; class qn extends tt { constructor(t, e = {}) { const { x: n, y: r, curve: o, tension: i } = e; super(t, [{ name: "x", value: n, scale: "x" }, { name: "y", value: r, scale: "y" }, { name: "z", value: bt(e), optional: !0 }], e, In), this.curve = tn(o, i) } render(t, { x: n, y: r }, o) { const { x: i, y: s, z: l } = o, { dx: c, dy: u } = this; return e.create("svg:g").call(w, this).call(M, n, r, y + c, y + u).call((n => n.selectAll().data(l ? e.group(t, (t => l[t])).values() : [t]).join("path").call(b, this).call(v, o).attr("d", e.line().curve(this.curve).defined((t => a(i[t]) && a(s[t]))).x((t => i[t])).y((t => s[t]))))).node() } } const Xn = { fill: "none", stroke: "currentColor", strokeMiterlimit: 1 }; class Un extends tt { constructor(t, e = {}) { const { x1: n, y1: r, x2: o, y2: i, curve: a } = e; super(t, [{ name: "x1", value: n, scale: "x" }, { name: "y1", value: r, scale: "y" }, { name: "x2", value: o, scale: "x", optional: !0 }, { name: "y2", value: i, scale: "y", optional: !0 }], e, Xn), this.curve = tn(a) } render(t, { x: n, y: r }, o) { const { x1: i, y1: a, x2: s = i, y2: l = a } = o, { dx: u, dy: f } = this, d = c(t, i, a, s, l); return e.create("svg:g").call(w, this).call(M, n, r, y + u, y + f).call((t => t.selectAll().data(d).join("path").call(b, this).attr("d", (t => { const n = e.path(), r = this.curve(n); return r.lineStart(), r.point(i[t], a[t]), r.point(s[t], l[t]), r.lineEnd(), `${n}` })).call(x, o))).node() } } function Wn(t, e, n) { if (void 0 === t) { if (void 0 === e) { if (void 0 !== n) return [n] } else if (void 0 === n) return [e] } else { if (void 0 === e) return void 0 === n ? [t] : [t, n]; if (void 0 === n) return [t, e] } return [e, n] } const Vn = {}; class Zn extends tt { constructor(t, e = {}) { const { x1: n, y1: r, x2: o, y2: i, inset: a = 0, insetTop: s = a, insetRight: l = a, insetBottom: c = a, insetLeft: u = a, rx: f, ry: d } = e; super(t, [{ name: "x1", value: n, scale: "x", optional: !0 }, { name: "y1", value: r, scale: "y", optional: !0 }, { name: "x2", value: o, scale: "x", optional: !0 }, { name: "y2", value: i, scale: "y", optional: !0 }], e, Vn), this.insetTop = st(s), this.insetRight = st(l), this.insetBottom = st(c), this.insetLeft = st(u), this.rx = R(f, "auto"), this.ry = R(d, "auto") } render(t, { x: n, y: r }, o, i) { const { x1: a, y1: s, x2: l, y2: u } = o, { marginTop: f, marginRight: d, marginBottom: h, marginLeft: m, width: p, height: g } = i, { insetTop: y, insetRight: v, insetBottom: R, insetLeft: $, dx: B, dy: A, rx: L, ry: T } = this, C = c(t, a, u, l, u); return e.create("svg:g").call(w, this).call(M, n, r, B, A).call((t => t.selectAll().data(C).join("rect").call(b, this).attr("x", a && l && !Ee(n) ? t => Math.min(a[t], l[t]) + $ : m + $).attr("y", s && u && !Ee(r) ? t => Math.min(s[t], u[t]) + y : f + y).attr("width", a && l && !Ee(n) ? t => Math.max(0, Math.abs(l[t] - a[t]) - $ - v) : p - d - m - v - $).attr("height", s && u && !Ee(r) ? t => Math.max(0, Math.abs(s[t] - u[t]) - y - R) : g - f - h - y - R).call(k, "rx", L).call(k, "ry", T).call(x, o))).node() } } const Hn = { fill: null, stroke: "currentColor" }; class Qn extends tt { constructor(t, e = {}) { const { x: n, y1: r, y2: o, inset: i = 0, insetTop: a = i, insetBottom: s = i } = e; super(t, [{ name: "x", value: n, scale: "x", optional: !0 }, { name: "y1", value: r, scale: "y", optional: !0 }, { name: "y2", value: o, scale: "y", optional: !0 }], e, Hn), this.insetTop = st(a), this.insetBottom = st(s) } render(t, { x: n, y: r }, o, i) { const { x: a, y1: s, y2: l } = o, { width: u, height: f, marginTop: d, marginRight: h, marginLeft: m, marginBottom: p } = i, { insetTop: g, insetBottom: v } = this, k = c(t, a, s, l); return e.create("svg:g").call(w, this).call(M, a && n, null, y, 0).call((t => t.selectAll("line").data(k).join("line").call(b, this).attr("x1", a ? t => a[t] : (m + u - h) / 2).attr("x2", a ? t => a[t] : (m + u - h) / 2).attr("y1", s && !Ee(r) ? t => s[t] + g : d + g).attr("y2", l && !Ee(r) ? r.bandwidth ? t => l[t] + r.bandwidth() - v : t => l[t] - v : f - p - v).call(x, o))).node() } } class Jn extends tt { constructor(t, e = {}) { const { x1: n, x2: r, y: o, inset: i = 0, insetRight: a = i, insetLeft: s = i } = e; super(t, [{ name: "y", value: o, scale: "y", optional: !0 }, { name: "x1", value: n, scale: "x", optional: !0 }, { name: "x2", value: r, scale: "x", optional: !0 }], e, Hn), this.insetRight = st(a), this.insetLeft = st(s) } render(t, { x: n, y: r }, o, i) { const { y: a, x1: s, x2: l } = o, { width: u, height: f, marginTop: d, marginRight: h, marginLeft: m, marginBottom: p } = i, { insetLeft: g, insetRight: v, dx: k, dy: R } = this, $ = c(t, a, s, l); return e.create("svg:g").call(w, this).call(M, null, a && r, k, y + R).call((t => t.selectAll("line").data($).join("line").call(b, this).attr("x1", s && !Ee(n) ? t => s[t] + g : m + g).attr("x2", l && !Ee(n) ? n.bandwidth ? t => l[t] + n.bandwidth() - v : t => l[t] - v : u - h - v).attr("y1", a ? t => a[t] : (d + f - p) / 2).attr("y2", a ? t => a[t] : (d + f - p) / 2).call(x, o))).node() } } function Kn(t, e, n) { if (void 0 === t) { if (void 0 === e) { if (void 0 !== n) return [0, n] } else if (void 0 === n) return [0, e] } else { if (void 0 === e) return void 0 === n ? [0, t] : [t, n]; if (void 0 === n) return [t, e] } return [e, n] } const tr = { strokeLinejoin: "round" }; class er extends tt { constructor(t, e = {}) { const { x: n, y: r, text: o = ot, textAnchor: i, fontFamily: a, fontSize: s, fontStyle: l, fontVariant: c, fontWeight: u, dx: f, dy: d = "0.32em", rotate: h } = e, [m, p] = mt(h, 0), [g, y] = mt(s); super(t, [{ name: "x", value: n, scale: "x", optional: !0 }, { name: "y", value: r, scale: "y", optional: !0 }, { name: "fontSize", value: Ot(g), optional: !0 }, { name: "rotate", value: Ot(m), optional: !0 }, { name: "text", value: o }], e, tr), this.rotate = p, this.textAnchor = at(i), this.fontFamily = at(a), this.fontSize = y, this.fontStyle = at(l), this.fontVariant = at(c), this.fontWeight = at(u), this.dx = at(f), this.dy = at(d) } render(t, { x: n, y: r }, o, i) { const { x: a, y: s, rotate: u, text: f, fontSize: d } = o, { width: h, height: m, marginTop: p, marginRight: g, marginBottom: v, marginLeft: w } = i, { rotate: b } = this, R = c(t, a, s, u).filter((t => l(f[t]))), $ = (w + h - g) / 2, B = (p + m - v) / 2; return e.create("svg:g").call(nr, this).call(M, n, r, y, y).call((t => t.selectAll().data(R).join("text").call(rr, this).call(u ? t => t.attr("transform", a && s ? t => `translate(${a[t]},${s[t]}) rotate(${u[t]})` : a ? t => `translate(${a[t]},${B}) rotate(${u[t]})` : s ? t => `translate(${$},${s[t]}) rotate(${u[t]})` : t => `translate(${$},${B}) rotate(${u[t]})`) : b ? t => t.attr("transform", a && s ? t => `translate(${a[t]},${s[t]}) rotate(${b})` : a ? t => `translate(${a[t]},${B}) rotate(${b})` : s ? t => `translate(${$},${s[t]}) rotate(${b})` : `translate(${$},${B}) rotate(${b})`) : t => t.attr("x", a ? t => a[t] : $).attr("y", s ? t => s[t] : B)).call(k, "font-size", d && (t => d[t])).text((t => f[t])).call(x, o))).node() } } function nr(t, e) { w(t, e), k(t, "text-anchor", e.textAnchor), k(t, "font-family", e.fontFamily), k(t, "font-size", e.fontSize), k(t, "font-style", e.fontStyle), k(t, "font-variant", e.fontVariant), k(t, "font-weight", e.fontWeight) } function rr(t, e) { b(t, e), k(t, "dx", e.dx), k(t, "dy", e.dy) } const or = { fill: null, stroke: "currentColor" }; class ir extends tt { constructor(t, e, n) { super(t, e, n, or) } render(t, n, r, o) { const { x: i, y: a } = r, { dx: s, dy: l } = this, u = c(t, i, a); return e.create("svg:g").call(w, this).call(this._transform, n, s, l).call((t => t.selectAll("line").data(u).join("line").call(b, this).attr("x1", this._x1(n, r, o)).attr("x2", this._x2(n, r, o)).attr("y1", this._y1(n, r, o)).attr("y2", this._y2(n, r, o)).call(x, r))).node() } } class ar extends ir { constructor(t, e = {}) { const { x: n, y: r, inset: o = 0, insetTop: i = o, insetBottom: a = o } = e; super(t, [{ name: "x", value: n, scale: "x" }, { name: "y", value: r, scale: "y", type: "band", optional: !0 }], e), this.insetTop = st(i), this.insetBottom = st(a) } _transform(t, { x: e }, n, r) { t.call(M, e, null, y + n, r) } _x1(t, { x: e }) { return t => e[t] } _x2(t, { x: e }) { return t => e[t] } _y1(t, { y: e }, { marginTop: n }) { const { insetTop: r } = this; return e ? t => e[t] + r : n + r } _y2({ y: t }, { y: e }, { height: n, marginBottom: r }) { const { insetBottom: o } = this; return e ? n => e[n] + t.bandwidth() - o : n - r - o } } class sr extends ir { constructor(t, e = {}) { const { x: n, y: r, inset: o = 0, insetRight: i = o, insetLeft: a = o } = e; super(t, [{ name: "y", value: r, scale: "y" }, { name: "x", value: n, scale: "x", type: "band", optional: !0 }], e), this.insetRight = st(i), this.insetLeft = st(a) } _transform(t, { y: e }, n, r) { t.call(M, null, e, n, y + r) } _x1(t, { x: e }, { marginLeft: n }) { const { insetLeft: r } = this; return e ? t => e[t] + r : n + r } _x2({ x: t }, { x: e }, { width: n, marginRight: r }) { const { insetRight: o } = this; return e ? n => e[n] + t.bandwidth() - o : n - r - o } _y1(t, { y: e }) { return t => e[t] } _y2(t, { y: e }) { return t => e[t] } } function lr(t, e, n, r, { data: o = X, filter: i = V, sort: a, reverse: s, ...l } = {}, c = {}) {
        t = fr(t), e = fr(e), l = Y(l, c), o = D(o, it), a = null == a ? void 0 : _("sort", a, c), i = null == i ? void 0 : j("filter", i, c), null != n && P(l, "x", "x1", "x2") && (n = null), null != r && P(l, "y", "y1", "y2") && (r = null); con
        st[u, f] = Lt(t), [d, h] = Lt(t), [m, p] = Lt(e), [g, y] = Lt(e), [x, v] = null != n ? [n, "x"] : null != r ? [r, "y"] : [], [w, b] = Lt(x), { x: k, y: M, z: R, fill: $, stroke: B, x1: A, x2: L, y1: T, y2: C, domain: O, cumulative: z, thresholds: E, ...S } = c, [q, U] = Lt(R), [W] = ht($), [Z] = ht(B), [H = $, Q] = Lt(W), [J = B, K] = Lt(Z); return { ..."z" in c && { z: q || R }, ..."fill" in c && { fill: H || $ }, ..."stroke" in c && { stroke: J || B }, ...N(S, ((n, r) => { const c = nt(n, x), u = nt(n, R), d = nt(n, W), m = nt(n, Z), g = F(l, u, d, m), v = [], w = [], k = c && b([]), M = u && U([]), $ = d && Q([]), B = m && K([]), A = t ? t(n) : [[, , t => t]], L = e ? e(n) : [[, , t => t]], T = t && f([]), C = t && h([]), O = e && p([]), z = e && y([]); let E = 0; for (const t of l) t.initialize(n); a && a.initialize(n), i && i.initialize(n); for (const t of r) { const e = []; for (const e of l) e.scope("facet", t); a && a.scope("facet", t), i && i.scope("facet", t); for (const [r, s] of G(t, g)) for (const [t, f] of G(s, c)) for (const [s, h, p] of A) { const y = p(f); for (const [f, p, x] of L) { const v = { x1: s, x2: h, y1: f, y2: p }, b = x(y); if (!i || i.reduce(b, v)) { e.push(E++), w.push(o.reduce(b, n, v)), c && k.push(t), u && M.push(g === u ? r : u[b[0]]), d && $.push(g === d ? r : d[b[0]]), m && B.push(g === m ? r : m[b[0]]), T && (T.push(s), C.push(h)), O && (O.push(f), z.push(p)); for (const t of l) t.reduce(b, v); a && a.reduce(b) } } } v.push(e) } return I(v, a, s), { data: w, facets: v } })), ...!P(l, "x") && (u ? { x1: u, x2: d, x: Tt(u, d) } : { x: k, x1: A, x2: L }), ...!P(l, "y") && (m ? { y1: m, y2: g, y: Tt(m, g) } : { y: M, y1: T, y2: C }), ...w && { [v]: w }, ...Object.fromEntries(l.map((({ name: t, output: e }) => [t, e]))) }
    } function cr({ cumulative: t, domain: e, thresholds: n, ...r }, o) { return [r, { cumulative: t, domain: e, thresholds: n, ...o }] } function ur(t, { cumulative: n, domain: r, thresholds: o }, i) { return void 0 === (t = { ...Ct(t) }).domain && (t.domain = r), void 0 === t.cumulative && (t.cumulative = n), void 0 === t.thresholds && (t.thresholds = o), void 0 === t.value && (t.value = i), t.thresholds = function (t = dr) { if ("string" == typeof t) { switch (t.toLowerCase()) { case "freedman-diaconis": return e.thresholdFreedmanDiaconis; case "scott": return e.thresholdScott; case "sturges": return e.thresholdSturges; case "auto": return dr }throw new Error("invalid thresholds") } return t }(t.thresholds), t } function fr(t) { if (null == t) return; const { value: n, cumulative: r, domain: o = e.extent, thresholds: i } = t, a = t => { let a = nt(t, n); const s = e.bin().value((t => a[t])); if (Et(a) || (function (t) { return hr(t) && "function" == typeof t && t() instanceof Date }(l = i) || l && l[Symbol.iterator] && Et(l))) { a = a.map(Ye); let [t, n] = "function" == typeof o ? o(a) : o, r = "function" != typeof i || hr(i) ? i : i(a, t, n); "number" == typeof r && (r = e.utcTickInterval(t, n, r)), hr(r) && (o === e.extent && (t = r.floor(t), n = r.ceil(new Date(+n + 1))), r = r.range(t, n)), s.thresholds(r).domain([t, n]) } else s.thresholds(i).domain(o); var l; let c = s(kt(t)).map(mr); return r && (c = (r < 0 ? c.reverse() : c).map(pr)), c.map(gr) }; return a.label = At(n), a } function dr(t, n, r) { return Math.min(200, e.thresholdScott(t, n, r)) } function hr(t) { return !!t && "function" == typeof t.range } function mr(t) { return [t, new Set(t)] } function pr([t], e, n) { return [t, { get size() { for (let t = 0; t <= e; ++t)if (n[t][1].size) return 1; return 0 }, has(t) { for (let r = 0; r <= e; ++r)if (n[r][1].has(t)) return !0; return !1 } }] } function gr([{ x0: t, x1: e }, n]) { return [t, e, n.size ? t => t.filter(n.has, n) : yr] } function yr() { return new Uint32Array(0) } function xr(t, e = {}) { return wr(Object.fromEntries(["x", "x1", "x2"].filter((t => null != e[t])).map((e => [e, t]))), e) } function vr(t, e = {}) { return wr(Object.fromEntries(["y", "y1", "y2"].filter((t => null != e[t])).map((e => [e, t]))), e) } function wr(t = {}, n = {}) { const r = bt(n), o = Object.entries(t).map((([t, e]) => { const r = $t(t, n); if (null == r) throw new Error(`missing channel: ${t}`); const [o, i] = Bt(r); return { key: t, input: r, output: o, setOutput: i, map: br(e) } })); return { ...N(n, ((t, n) => { const i = nt(t, r), a = o.map((({ input: e }) => nt(t, e))), s = o.map((({ setOutput: e }) => e(new Array(t.length)))); for (const t of n) for (const n of i ? e.group(t, (t => i[t])).values() : [t]) o.forEach((({ map: t }, e) => t.map(n, a[e], s[e]))); return { data: t, facets: n } })), ...Object.fromEntries(o.map((({ key: t, output: e }) => [t, e]))) } } function br(t) { if (t && "function" == typeof t.map) return t; if ("function" == typeof t) return Mr(t); switch (`${t}`.toLowerCase()) { case "cumsum": return Rr; case "rank": return Mr(e.rank); case "quantile": return Mr(kr) }throw new Error("invalid map") } function kr(t) { const n = e.count(t) - 1; return e.rank(t).map((t => t / n)) } function Mr(t) { return { map(e, n, r) { const o = t(Rt(n, e)); if (o.length !== e.length) throw new Error("mismatched length"); for (let t = 0, n = e.length; t < n; ++t)r[e[t]] = o[t] } } } const Rr = { map(t, e, n) { let r = 0; for (const o of t) n[o] = r += e[o] } }; function $r(t) { if (void 0 === t) return Lr; if ("function" == typeof t) return Br(((e, n) => t(Rt(n, e)))); switch (`${t}`.toLowerCase()) { case "first": return Lr; case "last": return Tr; case "mean": return Cr; case "median": return Or; case "sum": return zr; case "extent": return Ar }throw new Error("invalid basis") } function Br(t) { return { map(e, n, r) { const o = +t(e, n); for (const t of e) r[t] = null === n[t] ? NaN : n[t] / o } } } const Ar = { map(t, n, r) { const [o, i] = e.extent(t, (t => n[t])), a = i - o; for (const e of t) r[e] = null === n[e] ? NaN : (n[e] - o) / a } }, Lr = Br(((t, e) => { for (let n = 0; n < t.length; ++n) { const r = e[t[n]]; if (a(r)) return r } })), Tr = Br(((t, e) => { for (let n = t.length - 1; n >= 0; --n) { const r = e[t[n]]; if (a(r)) return r } })), Cr = Br(((t, n) => e.mean(t, (t => n[t])))), Or = Br(((t, n) => e.median(t, (t => n[t])))), zr = Br(((t, n) => e.sum(t, (t => n[t])))); function Er(t = {}) { "number" == typeof t && (t = { k: t }); let { k: n, reduce: r, shift: o, anchor: i = Nr(o) } = t; if (!((n = Math.floor(n)) > 0)) throw new Error("invalid k"); return function (t = "mean") { if ("string" == typeof t) switch (t.toLowerCase()) { case "deviation": return Sr(e.deviation); case "max": return Sr(e.max); case "mean": return Yr; case "median": return Sr(e.median); case "min": return Sr(e.min); case "mode": return Sr(e.mode); case "sum": return Pr; case "variance": return Sr(e.variance); case "difference": return _r; case "ratio": return jr }if ("function" != typeof t) throw new Error("invalid reduce"); return Sr(t) }(r)(n, function (t = "middle", e) { switch (`${t}`.toLowerCase()) { case "middle": return e - 1 >> 1; case "start": return 0; case "end": return e - 1 }throw new Error("invalid anchor") }(i, n)) } function Nr(t) { if (void 0 !== t) { switch (console.warn("shift is deprecated; please use anchor instead"), `${t}`.toLowerCase()) { case "centered": return "middle"; case "leading": return "start"; case "trailing": return "end" }throw new Error("invalid shift") } } function Sr(t) { return (e, n) => ({ map(r, o, i) { const a = Float64Array.from(r, (t => null === o[t] ? NaN : o[t])); let s = 0; for (let t = 0; t < e - 1; ++t)isNaN(a[t]) && ++s; for (let o = 0, l = r.length - e + 1; o < l; ++o)isNaN(a[o + e - 1]) && ++s, i[r[o + n]] = 0 === s ? t(a.subarray(o, o + e)) : NaN, isNaN(a[o]) && --s } }) } function Pr(t, e) { return { map(n, r, o) { let i = 0, a = 0; for (let e = 0; e < t - 1; ++e) { const t = r[n[e]]; null === t || isNaN(t) ? ++i : a += +t } for (let s = 0, l = n.length - t + 1; s < l; ++s) { const l = r[n[s]], c = r[n[s + t - 1]]; null === c || isNaN(c) ? ++i : a += +c, o[n[s + e]] = 0 === i ? a : NaN, null === l || isNaN(l) ? --i : a -= +l } } } } function Yr(t, e) { const n = Pr(t, e); return { map(r, o, i) { n.map(r, o, i); for (let n = 0, o = r.length - t + 1; n < o; ++n)i[r[n + e]] /= t } } } function _r(t, e) { return { map(n, r, o) { for (let i = 0, a = n.length - t; i < a; ++i) { const a = r[n[i]], s = r[n[i + t - 1]]; o[n[i + e]] = null === a || null === s ? NaN : s - a } } } } function jr(t, e) { return { map(n, r, o) { for (let i = 0, a = n.length - t; i < a; ++i) { const a = r[n[i]], s = r[n[i + t - 1]]; o[n[i + e]] = null === a || null === s ? NaN : s / a } } } } function* Gr(t) { yield t[0] } function* Dr(t) { yield t[t.length - 1] } function* Fr(t, n) { yield e.least(t, (t => n[t])) } function* Ir(t, n) { yield e.greatest(t, (t => n[t])) } function qr(t, n, r) { const o = bt(r); return N(r, ((r, i) => { const a = nt(r, o), s = nt(r, n), l = []; for (const n of i) { const r = []; for (const o of a ? e.group(n, (t => a[t])).values() : [n]) for (const e of t(o, s)) r.push(e); l.push(r) } return { data: r, facets: l } })) } t.Area = Bn, t.BarX = Pn, t.BarY = Yn, t.Cell = _n, t.Dot = Gn, t.Frame = Fn, t.Line = qn, t.Link = Un, t.Mark = tt, t.Rect = Zn, t.RuleX = Qn, t.RuleY = Jn, t.Text = er, t.TickX = ar, t.TickY = sr, t.area = function (t, e) { return new Bn(t, e) }, t.areaX = function (t, { y: e = ot, ...n } = {}) { return new Bn(t, an(en({ ...n, y1: e, y2: void 0 }))) }, t.areaY = function (t, { x: e = ot, ...n } = {}) { return new Bn(t, sn(nn({ ...n, x1: e, x2: void 0 }))) }, t.barX = function (t, e) { return new Pn(t, an(zn(en(e)))) }, t.barY = function (t, e) { return new Yn(t, sn(En(nn(e)))) }, t.bin = function (t = { fill: "count" }, e = {}) { [t, e] = cr(t, e); const { x: n, y: r } = function (t) { let { x: e, y: n } = t; return e = ur(e, t), n = ur(n, t), [e.value, n.value] = wt(e.value, n.value), { x: e, y: n } }(e); return lr(n, r, null, null, t, An(Ln(e))) }, t.binX = function (t = { y: "count" }, e = {}) { [t, e] = cr(t, e); const { x: n, y: r } = e; return lr(ur(n, e, it), null, null, r, t, An(e)) }, t.binY = function (t = { x: "count" }, e = {}) { [t, e] = cr(t, e); const { x: n, y: r } = e; return lr(null, ur(r, e, it), n, null, t, Ln(e)) }, t.cell = function (t, { x: e, y: n, ...r } = {}) { return [e, n] = wt(e, n), new _n(t, { ...r, x: e, y: n }) }, t.cellX = function (t, { x: e = ot, fill: n, stroke: r, ...o } = {}) { return void 0 === n && void 0 === ht(r)[0] && (n = it), new _n(t, { ...o, x: e, fill: n, stroke: r }) }, t.cellY = function (t, { y: e = ot, fill: n, stroke: r, ...o } = {}) { return void 0 === n && void 0 === ht(r)[0] && (n = it), new _n(t, { ...o, y: e, fill: n, stroke: r }) }, t.dot = function (t, { x: e, y: n, ...r } = {}) { return [e, n] = wt(e, n), new Gn(t, { ...r, x: e, y: n }) }, t.dotX = function (t, { x: e = it, ...n } = {}) { return new Gn(t, { ...n, x: e }) }, t.dotY = function (t, { y: e = it, ...n } = {}) { return new Gn(t, { ...n, y: e }) }, t.filter = function (t, e) { return N(e, T(t)) }, t.formatIsoDate = i, t.formatMonth = function (t = "en-US", e = "short") { const n = new Intl.DateTimeFormat(t, { timeZone: "UTC", month: e }); return t => { if (null != t && !isNaN(t = new Date(Date.UTC(2e3, +t)))) return n.format(t) } }, t.formatWeekday = function (t = "en-US", e = "short") { const n = new Intl.DateTimeFormat(t, { timeZone: "UTC", weekday: e }); return t => { if (null != t && !isNaN(t = new Date(Date.UTC(2001, 0, +t)))) return n.format(t) } }, t.frame = function (t) { return new Fn(t) }, t.group = function (t = { fill: "count" }, e = {}) { let { x: n, y: r } = e; if ([n, r] = wt(n, r), null == n) throw new Error("missing channel: x"); if (null == r) throw new Error("missing channel: y"); return S(n, r, t, e) }, t.groupX = function (t = { y: "count" }, e = {}) { const { x: n = it } = e; if (null == n) throw new Error("missing channel: x"); return S(n, null, t, e) }, t.groupY = function (t = { x: "count" }, e = {}) { const { y: n = it } = e; if (null == n) throw new Error("missing channel: y"); return S(null, n, t, e) }, t.groupZ = function (t, e) { return S(null, null, t, e) }, t.line = function (t, { x: e, y: n, ...r } = {}) { return [e, n] = wt(e, n), new qn(t, { ...r, x: e, y: n }) }, t.lineX = function (t, { x: e = it, y: n = ot, ...r } = {}) { return new qn(t, { ...r, x: e, y: n }) }, t.lineY = function (t, { x: e = ot, y: n = it, ...r } = {}) { return new qn(t, { ...r, x: e, y: n }) }, t.link = function (t, { x: e, x1: n, x2: r, y: o, y1: i, y2: a, ...s } = {}) { return [n, r] = Wn(e, n, r), [i, a] = Wn(o, i, a), new Un(t, { ...s, x1: n, x2: r, y1: i, y2: a }) }, t.map = wr, t.mapX = xr, t.mapY = vr, t.marks = function (...t) { return t.plot = tt.prototype.plot, t }, t.normalize = $r, t.normalizeX = function (t, e) { return 1 === arguments.length && ({ basis: t, ...e } = t), xr($r(t), e) }, t.normalizeY = function (t, e) { return 1 === arguments.length && ({ basis: t, ...e } = t), vr($r(t), e) }, t.plot = Qe, t.rect = function (t, e) { return new Zn(t, zn(En(e))) }, t.rectX = function (t, e) { return new Zn(t, an(En(en(e)))) }, t.rectY = function (t, e) { return new Zn(t, sn(zn(nn(e)))) }, t.reverse = function (t) { return N(t, C) }, t.ruleX = function (t, e) { let { x: n = it, y: r, y1: o, y2: i, ...a } = En(e); return [o, i] = Kn(r, o, i), new Qn(t, { ...a, x: n, y1: o, y2: i }) }, t.ruleY = function (t, e) { let { y: n = it, x: r, x1: o, x2: i, ...a } = zn(e); return [o, i] = Kn(r, o, i), new Jn(t, { ...a, y: n, x1: o, x2: i }) }, t.selectFirst = function (t) { return qr(Gr, void 0, t) }, t.selectLast = function (t) { return qr(Dr, void 0, t) }, t.selectMaxX = function (t = {}) { const e = t.x; if (null == e) throw new Error("missing channel: x"); return qr(Ir, e, t) }, t.selectMaxY = function (t = {}) { const e = t.y; if (null == e) throw new Error("missing channel: y"); return qr(Ir, e, t) }, t.selectMinX = function (t = {}) { const e = t.x; if (null == e) throw new Error("missing channel: x"); return qr(Fr, e, t) }, t.selectMinY = function (t = {}) { const e = t.y; if (null == e) throw new Error("missing channel: y"); return qr(Fr, e, t) }, t.shuffle = function ({ seed: t, ...n } = {}) { return N(n, E(null == t ? Math.random : e.randomLcg(t))) }, t.sort = function (t, e) { return N(e, O(t)) }, t.stackX = rn, t.stackX1 = function (t = {}, e = {}) { 1 === arguments.length && ([t, e] = cn(t)); const { y1: n, y: r = n, x: o } = e, [i, a, s] = un(r, o, "x", t, e); return { ...i, y1: n, y: a, x: s } }, t.stackX2 = function (t = {}, e = {}) { 1 === arguments.length && ([t, e] = cn(t)); const { y1: n, y: r = n, x: o } = e, [i, a, , s] = un(r, o, "x", t, e); return { ...i, y1: n, y: a, x: s } }, t.stackY = on, t.stackY1 = function (t = {}, e = {}) { 1 === arguments.length && ([t, e] = cn(t)); const { x1: n, x: r = n, y: o } = e, [i, a, s] = un(r, o, "y", t, e); return { ...i, x1: n, x: a, y: s } }, t.stackY2 = function (t = {}, e = {}) { 1 === arguments.length && ([t, e] = cn(t)); const { x1: n, x: r = n, y: o } = e, [i, a, , s] = un(r, o, "y", t, e); return { ...i, x1: n, x: a, y: s } }, t.text = function (t, { x: e, y: n, ...r } = {}) { return [e, n] = wt(e, n), new er(t, { ...r, x: e, y: n }) }, t.textX = function (t, { x: e = it, ...n } = {}) { return new er(t, { ...n, x: e }) }, t.textY = function (t, { y: e = it, ...n } = {}) { return new er(t, { ...n, y: e }) }, t.tickX = function (t, { x: e = it, ...n } = {}) { return new ar(t, { ...n, x: e }) }, t.tickY = function (t, { y: e = it, ...n } = {}) { return new sr(t, { ...n, y: e }) }, t.valueof = nt, t.version = "0.2.9", t.window = Er, t.windowX = function (t = {}, e) { return 1 === arguments.length && (e = t), xr(Er(t), e) }, t.windowY = function (t = {}, e) { return 1 === arguments.length && (e = t), vr(Er(t), e) }, Object.defineProperty(t, "__esModule", { value: !0 })
}));